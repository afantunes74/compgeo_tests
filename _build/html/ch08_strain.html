
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>8. Strain &#8212; Computational Geosciences</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="9. Elasticity" href="ch09_elasticity.html" />
    <link rel="prev" title="7. Stress" href="ch07_stress.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Computational Geosciences</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="intro.html">
                    Welcome to the Computational Geosciences resource
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  GET STARTED
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="preface.html">
   Preface
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="changelog.html">
   Changelog
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="todo.html">
   TODOs
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  CONTENTS
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="ch01_computation_geosciences.html">
   1. Computation in Geosciences
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ch02_understanding_location.html">
   2. Understanding location
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ch03_geological_features.html">
   3. Geological features
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ch04_coordinate_systems_vectors.html">
   4. Coordinate systems and vectors
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ch05_transformations.html">
   5. Transformations
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ch06_tensors.html">
   6. Tensors
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ch07_stress.html">
   7. Stress
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   8. Strain
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ch09_elasticity.html">
   9. Elasticity
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  THE COMPANION NOTEBOOKS
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch01/ch01_nb01.html">
   Introduction to Python and Jupyter Notebooks
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch02/ch02_nb01.html">
   Tissot’s Indicatrix
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch02/ch02_nb02.html">
   Defining the coordinate reference system
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch02/ch02_nb03.html">
   Coordinate conversion
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch02/ch02_nb04.html">
   Coordinate transformation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch02/ch02_nb05.html">
   Transform locations from lat-long to World Mercator
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch03/ch03_nb01.html">
   Plotting lines and poles in a stereonet
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch03/ch03_nb02.html">
   Maximum strike error vs. dip graph
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch03/ch03_nb03.html">
   Maximum trend error vs. dip graph [1]
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch03/ch03_nb04.html">
   Maximum trend error vs. dip graph [2]
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch04/ch04_nb01.html">
   Vector components, magnitude, and unit vectors
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch04/ch04_nb02.html">
   Vector operations
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch04/ch04_nb03.html">
   Mean vector
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch04/ch04_nb04.html">
   Angles, intersections, and poles
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch04/ch04_nb05.html">
   Three points problem
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch04/ch04_nb06.html">
   Uncertainties
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch05/ch05_nb01.html">
   Stratigraphic thickness
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch05/ch05_nb02.html">
   Stratigraphic thickness and uncertainties
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch05/ch05_nb03.html">
   Outcrop trace of a plane
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch05/ch05_nb04.html">
   Down-plunge projection
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch05/ch05_nb05.html">
   Rotations
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch05/ch05_nb06.html">
   Plotting great and small circles using rotations
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch06/ch06_nb01.html">
   Best-fit fold axis
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch06/ch06_nb02.html">
   Best-fit plane
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch07/ch07_nb01.html">
   Principal axes of stress
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch07/ch07_nb02.html">
   Normal and shear tractions on a plane
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch07/ch07_nb03.html">
   The Mohr circle for stress in 3D
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch08/ch08_nb01.html">
   P and T axes
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch08/ch08_nb02.html">
   2D strain from GPS data
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch08/ch08_nb03.html">
   2D finite strain from displacement data
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch08/ch08_nb04.html">
   Pure shear
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch08/ch08_nb05.html">
   Simple shear
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch08/ch08_nb06.html">
   General shear
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch09/ch09_nb01.html">
   Stresses around a circular hole
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch09/ch09_nb02.html">
   Lithospheric flexure
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch09/ch09_nb03.html">
   Faults as elastic dislocations
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="notebooks/ch09/ch09_nb04.html">
   Wave propagation
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://mybinder.org/v2/gh/afantunes74/compgeo_tests/master?urlpath=lab/tree/ch08_strain.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on Binder"
>
  

<span class="headerbtn__icon-container">
  
    <img src="_static/images/logo_binder.svg">
  </span>
<span class="headerbtn__text-container">Binder</span>
</a>

      </li>
      
      <li>
        
<button onclick="initThebeSBT()"
  class="headerbtn headerbtn-launch-thebe"
  data-toggle="tooltip"
data-placement="left"
title="Launch Thebe"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-play"></i>
  </span>
<span class="headerbtn__text-container">Live Code</span>
</button>

      </li>
      
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/afantunes74/compgeo_tests"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/afantunes74/compgeo_tests/issues/new?title=Issue%20on%20page%20%2Fch08_strain.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="_sources/ch08_strain.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#deformation-and-strain">
   8.1. Deformation and strain
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#deformation-and-displacement-gradients">
   8.2. Deformation and displacement gradients
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#infinitesimal-strain">
   8.3. Infinitesimal strain
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#mohr-circle-for-infinitesimal-strain">
     8.3.1. Mohr circle for infinitesimal strain
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#applications-of-infinitesimal-strain">
     8.3.2. Applications of Infinitesimal Strain
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#p-and-t-axes">
       8.3.2.1.
       <strong>
        P
       </strong>
       and
       <strong>
        T
       </strong>
       axes
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#d-strain-from-gps-data">
       8.3.2.2. 2D strain from GPS data
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#finite-strain">
   8.4. Finite strain
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#mohr-circle-for-finite-strain">
     8.4.1. Mohr circle for finite strain
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#d-finite-strain-from-displacement-data">
     8.4.2. 2D finite strain from displacement data
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#progressive-strain">
   8.5. Progressive strain
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#pure-shear">
     8.5.1. Pure shear
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#simple-shear">
     8.5.2. Simple shear
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#general-shear">
     8.5.3. General shear
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#exercises">
   8.6. Exercises
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#references">
   8.7. References
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Strain</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#deformation-and-strain">
   8.1. Deformation and strain
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#deformation-and-displacement-gradients">
   8.2. Deformation and displacement gradients
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#infinitesimal-strain">
   8.3. Infinitesimal strain
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#mohr-circle-for-infinitesimal-strain">
     8.3.1. Mohr circle for infinitesimal strain
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#applications-of-infinitesimal-strain">
     8.3.2. Applications of Infinitesimal Strain
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#p-and-t-axes">
       8.3.2.1.
       <strong>
        P
       </strong>
       and
       <strong>
        T
       </strong>
       axes
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#d-strain-from-gps-data">
       8.3.2.2. 2D strain from GPS data
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#finite-strain">
   8.4. Finite strain
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#mohr-circle-for-finite-strain">
     8.4.1. Mohr circle for finite strain
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#d-finite-strain-from-displacement-data">
     8.4.2. 2D finite strain from displacement data
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#progressive-strain">
   8.5. Progressive strain
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#pure-shear">
     8.5.1. Pure shear
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#simple-shear">
     8.5.2. Simple shear
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#general-shear">
     8.5.3. General shear
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#exercises">
   8.6. Exercises
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#references">
   8.7. References
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="strain">
<span id="ch08"></span><h1><span class="section-number">8. </span>Strain<a class="headerlink" href="#strain" title="Permalink to this headline">#</a></h1>
<p>Stresses acting through time within the Earth can lead to deformation. Deformation is more complicated than stress because it involves the comparison of states of the rock material at two different points in time. Therefore, one needs to establish both temporal and spatial reference frames. This chapter covers deformation and strain, including infinitesimal, finite, and progressive strain. This is a relatively long and complicated material, it comprises several chapters in classical books such as Ramsay (1967) and Means (1976). However, our purpose is not to discuss in detail the theory of strain, but rather introduce some interesting strain problems in geosciences, and their computation.</p>
<section id="deformation-and-strain">
<span id="ch08-1"></span><h2><span class="section-number">8.1. </span>Deformation and strain<a class="headerlink" href="#deformation-and-strain" title="Permalink to this headline">#</a></h2>
<p>Strictly speaking, deformation involves rigid body deformation (translation and rotation), and non-rigid body deformation (changes in shape and volume) or strain. In geology, rigid-body deformation is rather difficult to determine, with a few exceptions (e.g. paleolatitude of a continent from paleomagnetic pole). We often just focus on strain.</p>
<p>Consider the deformation shown in <a class="reference internal" href="#ch08-fig01"><span class="std std-numref">Figure 8.1</span></a>. The square and inscribed circle (<a class="reference internal" href="#ch08-fig01"><span class="std std-numref">Figure 8.1</span></a>a) are first translated, then rotated, and then sheared. The translation vector <strong>t</strong> (<a class="reference internal" href="#ch08-fig01"><span class="std std-numref">Figure 8.1</span></a>b) and rotation <span class="math notranslate nohighlight">\(\omega\)</span> (<a class="reference internal" href="#ch08-fig01"><span class="std std-numref">Figure 8.1</span></a>c) describe the first stage of rigid body-deformation. Shear of the objects defines the second stage of non-rigid body deformation or strain (<a class="reference internal" href="#ch08-fig01"><span class="std std-numref">Figure 8.1</span></a>d).</p>
<figure class="align-default" id="ch08-fig01">
<a class="reference internal image-reference" href="_images/ch08_fig01.png"><img alt="_images/ch08_fig01.png" src="_images/ch08_fig01.png" style="width: 400px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 8.1 </span><span class="caption-text">Deformation of a square of side <span class="math notranslate nohighlight">\(l_{i}\)</span> and inscribed circle. <strong>a.</strong> Initial configuration. <strong>b.</strong> Translation <span class="math notranslate nohighlight">\(\textbf{t}\)</span>. <strong>c.</strong> Rotation <span class="math notranslate nohighlight">\(\omega\)</span>. <strong>d.</strong> Shear. <span class="math notranslate nohighlight">\(l_{f}\)</span> and <span class="math notranslate nohighlight">\(\psi\)</span> are the final length and angular shear of the long side of the parallelogram. Red and blue lines in ellipse are principal axes and lines of no finite elongation (LNFE), respectively.</span><a class="headerlink" href="#ch08-fig01" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>The changes in shape (distortion) of the bodies can be described by the changes in length and angle of lines. If the initial length of a line is <span class="math notranslate nohighlight">\(l_i\)</span>, and the deformed length of the line is <span class="math notranslate nohighlight">\(l_f\)</span>, the change in length of the line can be defined by either one of the following parameters:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq01">
<span class="eqno">(8.1)<a class="headerlink" href="#equation-ch08-eq01" title="Permalink to this equation">#</a></span>\[\begin{split}
\begin{gathered}
    e = \frac{l_f-l_i}{l_i} \\
    S = \frac{l_f}{l_i} = 1 + e \\
    \lambda = S^2 = (1+e)^2
\end{gathered}
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(e\)</span> is elongation, <span class="math notranslate nohighlight">\(S\)</span> is stretch, and <span class="math notranslate nohighlight">\(\lambda\)</span> is quadratic elongation. For the long side of the parallelogram in <a class="reference internal" href="#ch08-fig01"><span class="std std-numref">Figure 8.1</span></a>d, <span class="math notranslate nohighlight">\(e\)</span> is positive, and <span class="math notranslate nohighlight">\(S\)</span> and <span class="math notranslate nohighlight">\(\lambda\)</span> are larger than <span class="math notranslate nohighlight">\(1\)</span>. For the short side, <span class="math notranslate nohighlight">\(e\)</span> is negative, and <span class="math notranslate nohighlight">\(S\)</span> and <span class="math notranslate nohighlight">\(\lambda\)</span> are lower than <span class="math notranslate nohighlight">\(1\)</span>. Lines that have their original length have <span class="math notranslate nohighlight">\(e = 0\)</span>, and <span class="math notranslate nohighlight">\(S\)</span> and <span class="math notranslate nohighlight">\(\lambda = 1\)</span> (blue lines, <a class="reference internal" href="#ch08-fig01"><span class="std std-numref">Figure 8.1</span></a>d). Notice than <span class="math notranslate nohighlight">\(e\)</span> cannot be lower than <span class="math notranslate nohighlight">\(-1\)</span>, and <span class="math notranslate nohighlight">\(S\)</span> and <span class="math notranslate nohighlight">\(\lambda\)</span> cannot be lower than 0 (a line can’t be shortened more than its original length).</p>
<p>Changes in angle are measured by the angular shear <span class="math notranslate nohighlight">\(\psi\)</span>, which is the change in angle between two originally perpendicular lines (<a class="reference internal" href="#ch08-fig01"><span class="std std-numref">Figure 8.1</span></a>d). From the angular shear, one can calculate the shear strain <span class="math notranslate nohighlight">\(\gamma\)</span>:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq02">
<span class="eqno">(8.2)<a class="headerlink" href="#equation-ch08-eq02" title="Permalink to this equation">#</a></span>\[
\gamma = \tan\psi
\]</div>
<p>Changes in area or volume (dilation) can be described using the areal or volumetric stretch:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq03">
<span class="eqno">(8.3)<a class="headerlink" href="#equation-ch08-eq03" title="Permalink to this equation">#</a></span>\[\begin{split}
\begin{gathered}
    S_A = \frac{A_f}{A_i} \\
    S_V = \frac{V_f}{V_i}
\end{gathered}
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(A_i\)</span> and <span class="math notranslate nohighlight">\(A_f\)</span> are initial and final area, and <span class="math notranslate nohighlight">\(V_i\)</span> and <span class="math notranslate nohighlight">\(V_f\)</span> are initial and final volume. We can also determine areal or volumetric elongation.</p>
<p>In this chapter, we make two major assumptions about strain: Strain is continuous (it is distributed uniformly across the body), and strain is homogeneous (it is identical across the body). Clearly these assumptions are incorrect: Rocks are full of discontinuities, and geological structures (e.g. folds) exhibit heterogeneous strain. However at the appropriate scale, rocks can be described as continuum materials, and the heterogeneous strain of geological structures can be represented by domains of homogeneous (yet compatible) strain. This makes possible applying homogeneous strain to geological deformation.</p>
<p>For homogeneous strain, straight lines remain straight, parallel lines remain parallel, and circles become ellipses in 2D, or spheres become ellipsoids in 3D (<a class="reference internal" href="#ch08-fig01"><span class="std std-numref">Figure 8.1</span></a>d). The resultant ellipse (or ellipsoid) is called the strain ellipse (or ellipsoid). The stretches along the axes of this ellipse (or ellipsoid, red lines in <a class="reference internal" href="#ch08-fig01"><span class="std std-numref">Figure 8.1</span></a>d) are called the principal stretches, and they are denoted by the symbols <span class="math notranslate nohighlight">\(S_1\)</span>, <span class="math notranslate nohighlight">\(S_2\)</span>, <span class="math notranslate nohighlight">\(S_3\)</span>, for the maximum, intermediate, and minimum principal stretch, respectively. The volumetric stretch can also be defined as:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq04">
<span class="eqno">(8.4)<a class="headerlink" href="#equation-ch08-eq04" title="Permalink to this equation">#</a></span>\[
S_V = S_1S_2S_3
\]</div>
<p>The deformation in <a class="reference internal" href="#ch08-fig01"><span class="std std-numref">Figure 8.1</span></a> is volume and area constant (<span class="math notranslate nohighlight">\(S_V\)</span> and <span class="math notranslate nohighlight">\(S_A = 1\)</span>). Under this condition, there are two lines in the strain ellipse that have their original length (blue lines, <a class="reference internal" href="#ch08-fig01"><span class="std std-numref">Figure 8.1</span></a>d). These lines are known as the lines of no finite elongation (LNFE).</p>
</section>
<section id="deformation-and-displacement-gradients">
<span id="ch08-2"></span><h2><span class="section-number">8.2. </span>Deformation and displacement gradients<a class="headerlink" href="#deformation-and-displacement-gradients" title="Permalink to this headline">#</a></h2>
<p>Consider the deformation shown in <a class="reference internal" href="#ch08-fig02"><span class="std std-numref">Figure 8.2</span></a>. The cube is transformed into a brick-shaped body. It is shortened along the <span class="math notranslate nohighlight">\(\mathbf{X_2}\)</span> axis by half (<span class="math notranslate nohighlight">\(e = -0.5\)</span>, <span class="math notranslate nohighlight">\(S = 0.5\)</span>), and it is stretched along the <span class="math notranslate nohighlight">\(\mathbf{X_3}\)</span> axis twice (<span class="math notranslate nohighlight">\(e = 1\)</span>, <span class="math notranslate nohighlight">\(S = 2\)</span>).</p>
<figure class="align-default" id="ch08-fig02">
<a class="reference internal image-reference" href="_images/ch08_fig02.png"><img alt="_images/ch08_fig02.png" src="_images/ch08_fig02.png" style="width: 400px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 8.2 </span><span class="caption-text">Deformation of a cube in to a brick-shaped body. The principal axes of strain are parallel to the coordinate axes before <span class="math notranslate nohighlight">\(\textbf{X}\)</span> and after <span class="math notranslate nohighlight">\(\textbf{x}\)</span> deformation. Modified from Means (1976).</span><a class="headerlink" href="#ch08-fig02" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>We can express the deformed coordinates <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> of any point in the cuboid in terms of the undeformed coordinates <span class="math notranslate nohighlight">\(\mathbf{X}\)</span> of the same point in the cube:</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>By convention, we use <span class="math notranslate nohighlight">\(\mathbf{X}\)</span> to refer to the undeformed coordinates, and <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> to denote the deformed coordinates.</p>
</div>
<div class="math notranslate nohighlight" id="equation-ch08-eq05">
<span class="eqno">(8.5)<a class="headerlink" href="#equation-ch08-eq05" title="Permalink to this equation">#</a></span>\[\begin{split}
\begin{gathered}
    x_1 = 1 X_1 + 0 X_2 + 0 X_3 \\
    x_2 = 0 X_1 + 0.5 X_2 + 0 X_3 \\
    x_3 = 0 X_1 + 0 X_2 + 2 X_3
\end{gathered}
\end{split}\]</div>
<p>Likewise, we can express the undeformed coordinates <span class="math notranslate nohighlight">\(\mathbf{X}\)</span> of any point in the cube in terms of the deformed coordinates <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> of the same point in the cuboid:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq06">
<span class="eqno">(8.6)<a class="headerlink" href="#equation-ch08-eq06" title="Permalink to this equation">#</a></span>\[\begin{split}
\begin{gathered}
    X_1 = 1 x_1 + 0 x_2 + 0 x_3 \\
    X_2 = 0 x_1 + 2 x_2 + 0 x_3 \\
    X_3 = 0 x_1 + 0 x_2 + 0.5 x_3
\end{gathered}
\end{split}\]</div>
<p>Equations <a class="reference internal" href="#equation-ch08-eq05">(8.5)</a> and <a class="reference internal" href="#equation-ch08-eq06">(8.6)</a> are called <em>coordinate transformations</em>, but they are fundamentally different from the transformation of coordinate axes in <a class="reference internal" href="ch05_transformations.html#ch05"><span class="std std-ref">Chapter 5</span></a>. The coordinate transformations here are between two different states in time. Eq. <a class="reference internal" href="#equation-ch08-eq05">(8.5)</a> is called a <em>Green</em> transformation (new in terms of old), while Eq. <a class="reference internal" href="#equation-ch08-eq06">(8.6)</a> is a <em>Cauchy</em> transformation (old in terms of new).</p>
<p>We can take the partial derivatives of these equations, which are just the coefficients of the equations:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq07">
<span class="eqno">(8.7)<a class="headerlink" href="#equation-ch08-eq07" title="Permalink to this equation">#</a></span>\[\begin{split}
\frac{\partial x_i}{\partial X_j}=\begin{bmatrix}1&amp;0&amp;0\\0&amp;0.5&amp;0\\0&amp;0&amp;2\end{bmatrix}
\end{split}\]</div>
<p>and:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq08">
<span class="eqno">(8.8)<a class="headerlink" href="#equation-ch08-eq08" title="Permalink to this equation">#</a></span>\[\begin{split}
\frac{\partial X_i}{\partial x_j}=\begin{bmatrix}1&amp;0&amp;0\\0&amp;2&amp;0\\0&amp;0&amp;0.5\end{bmatrix}
\end{split}\]</div>
<p>These partial derivatives are known as the deformation gradients and unlike the coordinate transformations, they are homogeneous and independent of the coordinate axes (i.e. they are tensors). Eq. <a class="reference internal" href="#equation-ch08-eq07">(8.7)</a> is called the <em>Green</em> deformation gradient, while Eq. <a class="reference internal" href="#equation-ch08-eq08">(8.8)</a> is the <em>Cauchy</em> deformation gradient. Since in <a class="reference internal" href="#ch08-fig02"><span class="std std-numref">Figure 8.2</span></a> the principal axes of strain are parallel to the coordinate axes, we can easily see one thing: The components of the Green deformation gradient are the stretches along the coordinate axes, and the components of the Cauchy deformation gradient are the inverse of the stretches along the coordinate axes. For more complex situations this will not be the case, but in general the Green and Cauchy deformation gradient tensors are related to the stretch (Allmendinger et al., 2012).</p>
<p>Another way to study the deformation is to look at the displacement <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> between the undeformed and deformed states (<a class="reference internal" href="#ch08-fig02"><span class="std std-numref">Figure 8.2</span></a>). The displacement can either be expressed in the undeformed configuration:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq09">
<span class="eqno">(8.9)<a class="headerlink" href="#equation-ch08-eq09" title="Permalink to this equation">#</a></span>\[\begin{split}
\begin{gathered}
    u_1 = 0 X_1 + 0 X_2 + 0 X_3 \\
    u_2 = 0 X_1 - 0.5 X_2 + 0 X_3 \\
    u_3 = 0 X_1 + 0 X_2 + 1 X_3
\end{gathered}
\end{split}\]</div>
<p>or in the deformed configuration:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq10">
<span class="eqno">(8.10)<a class="headerlink" href="#equation-ch08-eq10" title="Permalink to this equation">#</a></span>\[\begin{split}
\begin{gathered}
    u_1 = 0 x_1 + 0 x_2 + 0 x_3 \\
    u_2 = 0 x_1 - 1 x_2 + 0 x_3 \\
    u_3 = 0 x_1 + 0 x_2 + 0.5 x_3
\end{gathered}
\end{split}\]</div>
<p>Eq. <a class="reference internal" href="#equation-ch08-eq09">(8.9)</a> is known as the <em>Lagrangian</em> displacement (in terms of old coordinates), while Eq. <a class="reference internal" href="#equation-ch08-eq09">(8.9)</a> is the <em>Eulerian</em> displacement (in terms of new coordinates). We can take the partial derivatives of these equations, which are just the coefficients of the equations:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq11">
<span class="eqno">(8.11)<a class="headerlink" href="#equation-ch08-eq11" title="Permalink to this equation">#</a></span>\[\begin{split}
\frac{\partial u_i}{\partial X_j}=\begin{bmatrix}0&amp;0&amp;0\\0&amp;-0.5&amp;0\\0&amp;0&amp;1\end{bmatrix}
\end{split}\]</div>
<p>and:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq12">
<span class="eqno">(8.12)<a class="headerlink" href="#equation-ch08-eq12" title="Permalink to this equation">#</a></span>\[\begin{split}
\frac{\partial u_i}{\partial x_j}=\begin{bmatrix}0&amp;0&amp;0\\0&amp;-1&amp;0\\0&amp;0&amp;0.5\end{bmatrix}
\end{split}\]</div>
<p>These partial derivatives are known as the displacement gradients and unlike the displacement, they are homogeneous and independent of the coordinate axes (i.e. they are tensors). Eq. <a class="reference internal" href="#equation-ch08-eq11">(8.11)</a> is called the <em>Lagrangian</em> displacement gradient, while Eq. <a class="reference internal" href="#equation-ch08-eq12">(8.12)</a> is the <em>Eulerian</em> displacement gradient. For the case of <a class="reference internal" href="#ch08-fig02"><span class="std std-numref">Figure 8.2</span></a>, we can see that the components of the Lagrangian displacement gradient are the elongations along the coordinate axes, while the components of the Eulerian displacement gradient are the elongations along the coordinate axes with respect to the deformed reference frame (<span class="math notranslate nohighlight">\(\tilde{e}=(l_f-l_i)/l_f\)</span>). This will not be the case for more complicated situations, but in general the Lagrangian and Eulerian displacement gradient tensors are related to the elongation (Allmendinger et al., 2012).</p>
<p><a class="reference internal" href="#ch08-tab01"><span class="std std-numref">Table 8.1</span></a> summarizes this section.</p>
<table class="table" id="ch08-tab01">
<caption><span class="caption-number">Table 8.1 </span><span class="caption-text">Coordinate transformations and displacement via deformation and displacement gradient tensors. Rigid body deformation is not included.</span><a class="headerlink" href="#ch08-tab01" title="Permalink to this table">#</a></caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head"><p>Old coordinates</p></th>
<th class="head"><p>New coordinates</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Coordinate transformations</p></td>
<td><p>Green <span class="math notranslate nohighlight">\(x_i=\frac{\partial x_i}{\partial X_j}X_j\)</span></p></td>
<td><p>Cauchy <span class="math notranslate nohighlight">\(X_i=\frac{\partial X_i}{\partial x_j}x_j\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>Displacement</p></td>
<td><p>Lagrangian <span class="math notranslate nohighlight">\(u_i=\frac{\partial u_i}{\partial X_j}X_j\)</span></p></td>
<td><p>Eulerian <span class="math notranslate nohighlight">\(u_i=\frac{\partial u_i}{\partial x_j}x_j\)</span></p></td>
</tr>
</tbody>
</table>
</section>
<section id="infinitesimal-strain">
<span id="ch08-3"></span><h2><span class="section-number">8.3. </span>Infinitesimal strain<a class="headerlink" href="#infinitesimal-strain" title="Permalink to this headline">#</a></h2>
<p>Suppose that a line parallel to the <span class="math notranslate nohighlight">\(\mathbf{X_1}\)</span> axis is elongated 1<span class="math notranslate nohighlight">\(\%\)</span> of its initial length. In this case the displacement gradient is:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq13">
<span class="eqno">(8.13)<a class="headerlink" href="#equation-ch08-eq13" title="Permalink to this equation">#</a></span>\[
\frac{\partial u_1}{\partial X_1} = \frac{0.01}{1.0} = 0.01 \quad\quad \text{and} \quad\quad \frac{\partial u_1}{\partial x_1} = \frac{0.01}{1.01} = 0.0099
\]</div>
<p>Thus, when strains are small (<span class="math notranslate nohighlight">\(e &lt; 1\%\)</span>), <span class="math notranslate nohighlight">\(\frac{\partial u_i}{\partial X_i} \approx \frac{\partial u_i}{\partial x_i}\)</span>, and the difference between the displacement gradient in the initial or final state is insignificant. Small strains are called <em>infinitesimal strains</em>, and they are important in a number of fields in geosciences, particularly in geophysics.</p>
<p>For infinitesimal strain, the distinction between old and new coordinates is irrelevant, and therefore we can just use one column in <a class="reference internal" href="#ch08-tab01"><span class="std std-numref">Table 8.1</span></a>. The displacement gradient <span class="math notranslate nohighlight">\(\mathbf{e}\)</span> is an asymmetric tensor, and it can be decomposed into a symmetric and an antisymmetric tensor (Eq. <a class="reference internal" href="#equation-ch08-eq14">(8.14)</a>):</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We use <span class="math notranslate nohighlight">\(\mathbf{e}\)</span> to denote the displacement gradient. This is different than the non-bold italic letter <span class="math notranslate nohighlight">\(e\)</span> which is used for elongation.</p>
</div>
<div class="math notranslate nohighlight" id="equation-ch08-eq14">
<span class="eqno">(8.14)<a class="headerlink" href="#equation-ch08-eq14" title="Permalink to this equation">#</a></span>\[
e_{ij} = \varepsilon_{ij} + \omega_{ij}
\]</div>
<p>where:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq15">
<span class="eqno">(8.15)<a class="headerlink" href="#equation-ch08-eq15" title="Permalink to this equation">#</a></span>\[\begin{split}\label{eq8.14} \varepsilon_{ij}=\frac{1}{2}(e_{ij}+e_{ji})=\begin{bmatrix}e_{11}&amp;\frac{e_{12}+e_{21}}{2}&amp;\frac{e_{13}+e_{31}}{2}\\ \frac{e_{21}+e_{12}}{2}&amp;e_{22}&amp;\frac{e_{23}+e_{32}}{2}\\ \frac{e_{31}+e_{13}}{2}&amp;\frac{e_{32}+e_{23}}{2}&amp;e_{33}\end{bmatrix}
\end{split}\]</div>
<p>and:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq16">
<span class="eqno">(8.16)<a class="headerlink" href="#equation-ch08-eq16" title="Permalink to this equation">#</a></span>\[\begin{split}
\omega_{ij}=\frac{1}{2}(e_{ij}-e_{ji})=\begin{bmatrix}0&amp;\frac{e_{12}-e_{21}}{2}&amp;\frac{e_{13}-e_{31}}{2}\\ \frac{e_{21}-e_{12}}{2}&amp;0&amp;\frac{e_{23}-e_{32}}{2}\\ \frac{e_{31}-e_{13}}{2}&amp;\frac{e_{32}-e_{23}}{2}&amp;0\end{bmatrix}
\end{split}\]</div>
<p>The symmetric tensor <span class="math notranslate nohighlight">\(\boldsymbol{\varepsilon}\)</span> is called the strain tensor. The diagonal, <span class="math notranslate nohighlight">\(\varepsilon_{ii}\)</span>, terms of this tensor correspond to the elongations along the axes of the reference system, and the off-diagonal terms, <span class="math notranslate nohighlight">\(\varepsilon_{ij}\)</span>, correspond to half the shear strain (<span class="math notranslate nohighlight">\(\varepsilon_{ij} = \frac{\gamma_{ij}}{2}\)</span>). Like any symmetric tensor, the strain tensor has three principal axes which can be determined by computing the eigenvalues and eigenvectors of the tensor (<a class="reference internal" href="ch06_tensors.html#ch06-2"><span class="std std-ref">Section 6.2</span></a>). These principal axes define the infinitesimal strain ellipsoid.</p>
<p>The antisymmetric tensor <span class="math notranslate nohighlight">\(\boldsymbol{\omega}\)</span> is also known as an axial vector. The Cartesian coordinates, <span class="math notranslate nohighlight">\(r_i\)</span>, of this vector give the orientation of the rotation axis:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq17">
<span class="eqno">(8.17)<a class="headerlink" href="#equation-ch08-eq17" title="Permalink to this equation">#</a></span>\[
r_1=\frac{-(\omega_{23}-\omega_{32})}{2}\quad r_2=\frac{-(-\omega_{13}+\omega_{31})}{2}\quad \text{and}\quad r_3=\frac{-(\omega_{12}-\omega_{21})}{2}
\]</div>
<p>The amount of rotation in radians is just the length of the vector <span class="math notranslate nohighlight">\(\mathbf{r}\)</span>:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq18">
<span class="eqno">(8.18)<a class="headerlink" href="#equation-ch08-eq18" title="Permalink to this equation">#</a></span>\[
\omega = \vert \mathbf{r}\vert = \sqrt{r_1^2+r_2^2+r_3^2}
\]</div>
<p>The function <a class="reference external" href="https://github.com/nfcd/compGeo/blob/master/source/functions/inf_strain.py">inf_strain</a> computes the infinitesimal strain and rotation tensors from a displacement gradient. It also outputs the principal strains, and the components and amount of rotation:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">compgeo.cart_to_sph</span> <span class="kn">import</span> <span class="n">cart_to_sph</span>
<span class="kn">from</span> <span class="nn">compgeo.zero_twopi</span> <span class="kn">import</span> <span class="n">zero_twopi</span>


<span class="k">def</span> <span class="nf">inf_strain</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    inf_strain computes infinitesimal strain from an input</span>
<span class="sd">    displacement gradient tensor</span>

<span class="sd">    USE: eps,ome,pstrain,rotc,rot = inf_strain(e)</span>

<span class="sd">    e = 3 x 3 displacement gradient tensor</span>
<span class="sd">    eps = 3 x 3 strain tensor</span>
<span class="sd">    ome = 3 x 3 rotation tensor</span>
<span class="sd">    pstrain = 3 x 3 matrix with magnitude (column 1), trend</span>
<span class="sd">            (column 2) and plunge (column 3) of maximum</span>
<span class="sd">            (row 1), intermediate (row 2),and minimum </span>
<span class="sd">            (row 3) principal strains</span>
<span class="sd">    rotc = 1 x 3 vector with rotation components</span>
<span class="sd">    rot = 1 x 3 vector with rotation magnitude and trend</span>
<span class="sd">        and plunge of rotation axis</span>

<span class="sd">    NOTE: Output trends and plunges of principal strains</span>
<span class="sd">        and rotation axes are in radians</span>

<span class="sd">    Python function translated from the Matlab function</span>
<span class="sd">    InfStrain in Allmendinger et al. (2012)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialize variables</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">ome</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">pstrain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">rotc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">rot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

    <span class="c1"># Compute strain and rotation tensors</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">e</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">])</span>
            <span class="n">ome</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">e</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">])</span>

    <span class="c1"># Compute principal strains and orientations.</span>
    <span class="c1"># Here we use the function eigh. D is a vector</span>
    <span class="c1"># of eigenvalues (i.e. principal strains), and V is a</span>
    <span class="c1"># full matrix whose columns are the corresponding</span>
    <span class="c1"># eigenvectors (i.e. principal strain directions)</span>
    <span class="n">D</span><span class="p">,</span><span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">eps</span><span class="p">)</span>

    <span class="c1"># Maximum principal strain</span>
    <span class="n">pstrain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">pstrain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">pstrain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cart_to_sph</span><span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="n">V</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
    
    <span class="c1"># Intermediate principal strain</span>
    <span class="n">pstrain</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> 
    <span class="n">pstrain</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">pstrain</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cart_to_sph</span><span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">V</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="c1"># Minimum principal strain</span>
    <span class="n">pstrain</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 
    <span class="n">pstrain</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">pstrain</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cart_to_sph</span><span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">V</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Calculate rotation components</span>
    <span class="n">rotc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">ome</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">ome</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">*-</span><span class="mf">0.5</span>
    <span class="n">rotc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="n">ome</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">ome</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">*-</span><span class="mf">0.5</span>
    <span class="n">rotc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">ome</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ome</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">*-</span><span class="mf">0.5</span>

    <span class="c1"># Compute rotation magnitude</span>
    <span class="n">rot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rotc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">rotc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">rotc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="c1"># Compute trend and plunge of rotation axis</span>
    <span class="n">rot</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">rot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cart_to_sph</span><span class="p">(</span><span class="n">rotc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">rot</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                <span class="n">rotc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">rot</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                <span class="n">rotc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="n">rot</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="c1"># If plunge is negative</span>
    <span class="k">if</span> <span class="n">rot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">rot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">zero_twopi</span><span class="p">(</span><span class="n">rot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="n">rot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">rot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">return</span> <span class="n">eps</span><span class="p">,</span> <span class="n">ome</span><span class="p">,</span> <span class="n">pstrain</span><span class="p">,</span> <span class="n">rotc</span><span class="p">,</span> <span class="n">rot</span>
</pre></div>
</div>
</div>
</div>
<section id="mohr-circle-for-infinitesimal-strain">
<span id="ch08-3-1"></span><h3><span class="section-number">8.3.1. </span>Mohr circle for infinitesimal strain<a class="headerlink" href="#mohr-circle-for-infinitesimal-strain" title="Permalink to this headline">#</a></h3>
<p>As discussed in <a class="reference internal" href="ch06_tensors.html#ch06-4-1"><span class="std std-ref">Section 6.4.1</span></a>, the rotation of the infinitesimal strain tensor about one principal axis can be represented by a Mohr circle. We start with the infinitesimal strain tensor in principal coordinates:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq19">
<span class="eqno">(8.19)<a class="headerlink" href="#equation-ch08-eq19" title="Permalink to this equation">#</a></span>\[\begin{split}
\varepsilon_{ij}=\begin{bmatrix}\varepsilon_1&amp;0&amp;0\\ 0&amp;\varepsilon_2&amp;0\\ 0&amp;0&amp;\varepsilon_3\end{bmatrix}
\end{split}\]</div>
<p>and perform a rotation <span class="math notranslate nohighlight">\(\theta\)</span> about <span class="math notranslate nohighlight">\(\mathbf{X_2}\)</span> (<a class="reference internal" href="#ch08-fig03"><span class="std std-numref">Figure 8.3</span></a>a), which is described by the transformation matrix:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq20">
<span class="eqno">(8.20)<a class="headerlink" href="#equation-ch08-eq20" title="Permalink to this equation">#</a></span>\[\begin{split}
a_{ij} = \begin{pmatrix}\cos\theta&amp;0&amp;\sin\theta\\0&amp;1&amp;0\\-\sin\theta&amp;0&amp;\cos\theta\end{pmatrix}
\end{split}\]</div>
<p>The tensor transformation equation is:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq21">
<span class="eqno">(8.21)<a class="headerlink" href="#equation-ch08-eq21" title="Permalink to this equation">#</a></span>\[
\varepsilon_{ij}' = a_{ik}a_{jl}\varepsilon_{kl}
\]</div>
<p>which results in the new form of the strain tensor:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq22">
<span class="eqno">(8.22)<a class="headerlink" href="#equation-ch08-eq22" title="Permalink to this equation">#</a></span>\[\begin{split}
\varepsilon'_{ij}=\begin{bmatrix}\varepsilon_1\cos^2\theta+\varepsilon_3\sin^2\theta&amp;0&amp;-(\varepsilon_1-\varepsilon_3)\sin\theta\cos\theta\\0&amp;\varepsilon_2&amp;0\\-(\varepsilon_1-\varepsilon_3)\sin\theta\cos\theta&amp;0&amp;\varepsilon_1\sin^2\theta+\varepsilon_3\cos^2\theta\end{bmatrix}
\end{split}\]</div>
<figure class="align-default" id="ch08-fig03">
<a class="reference internal image-reference" href="_images/ch08_fig03.png"><img alt="_images/ch08_fig03.png" src="_images/ch08_fig03.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 8.3 </span><span class="caption-text">Rotation of the infinitesimal strain tensor about principal axis <span class="math notranslate nohighlight">\(\mathbf{X_2}\)</span>. <strong>a.</strong> Physical plane representation, <strong>b.</strong> Mohr circle representation. Modified from Allmendinger et al. (2012).</span><a class="headerlink" href="#ch08-fig03" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Upon rearranging, we get:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq23">
<span class="eqno">(8.23)<a class="headerlink" href="#equation-ch08-eq23" title="Permalink to this equation">#</a></span>\[\begin{split}
\begin{gathered}
    \varepsilon_{11}'=\frac{\varepsilon_1+\varepsilon_3}{2}+\frac{\varepsilon_1-\varepsilon_3}{2}\cos 2\theta \\
    \varepsilon_{33}'=\frac{\varepsilon_1+\varepsilon_3}{2}-\frac{\varepsilon_1-\varepsilon_3}{2}\cos 2\theta \\
    \varepsilon_{13}'=\varepsilon_{31}'=\frac{\gamma}{2}=-\frac{\varepsilon_1-\varepsilon_3}{2}\sin 2\theta
\end{gathered}
\end{split}\]</div>
<p>which are the equations of the Mohr circle for infinitesimal strain (<a class="reference internal" href="#ch08-fig03"><span class="std std-numref">Figure 8.3</span></a>b). This Mohr circle is not very useful, but perhaps the most important thing illustrated by it is that the two directions of maximum shear strain are at <span class="math notranslate nohighlight">\(\pm\)</span><!-- -->45to the principal axes, <span class="math notranslate nohighlight">\(\varepsilon_1\)</span> and <span class="math notranslate nohighlight">\(\varepsilon_3\)</span> (<a class="reference internal" href="#ch08-fig03"><span class="std std-numref">Figure 8.3</span></a>b). Turning this around for the infinitesimal strain in a shear zone, the infinitesimal shortening and extension directions are always at 45to the shear zone. For example, veins and foliations at the edge of a shear zone, and P and T axes of earthquakes (<a class="reference internal" href="#ch08-3-2"><span class="std std-ref">Section 8.3.2</span></a>) are all oriented 45to the shear (fault) zone (<a class="reference internal" href="#ch08-fig04"><span class="std std-numref">Figure 8.4</span></a>).</p>
<figure class="align-default" id="ch08-fig04">
<a class="reference internal image-reference" href="_images/ch08_fig04.png"><img alt="_images/ch08_fig04.png" src="_images/ch08_fig04.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 8.4 </span><span class="caption-text">The infinitesimal extension and shortening directions are always at 45<span class="math notranslate nohighlight">\(^o\)</span> to the shear zone. <strong>a.</strong> Sigmoidal veins, <strong>b.</strong> Foliation, and <strong>c.</strong> P and T axes of earthquakes. Modified from Allmendinger et al. (2012).</span><a class="headerlink" href="#ch08-fig04" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="applications-of-infinitesimal-strain">
<span id="ch08-3-2"></span><h3><span class="section-number">8.3.2. </span>Applications of Infinitesimal Strain<a class="headerlink" href="#applications-of-infinitesimal-strain" title="Permalink to this headline">#</a></h3>
<section id="p-and-t-axes">
<span id="ch08-3-2-1"></span><h4><span class="section-number">8.3.2.1. </span><strong>P</strong> and <strong>T</strong> axes<a class="headerlink" href="#p-and-t-axes" title="Permalink to this headline">#</a></h4>
<p>Our first application is based on the observation we just made regarding the orientation of the principal axes of infinitesimal strain with respect to a shear zone (<a class="reference internal" href="#ch08-fig04"><span class="std std-numref">Figure 8.4</span></a>). In a fault, the infinitesimal shortening <strong>P</strong> and extension <strong>T</strong> axes are at 45<span class="math notranslate nohighlight">\(^o\)</span> to the slip vector (e.g. fault striae), and they lie on the plane defined by the fault striae and the fault pole. This plane is known as the movement plane <span class="math notranslate nohighlight">\(M\)</span> (<a class="reference internal" href="#ch08-fig05"><span class="std std-numref">Figure 8.5</span></a>).</p>
<figure class="align-default" id="ch08-fig05">
<a class="reference internal image-reference" href="_images/ch08_fig05.png"><img alt="_images/ch08_fig05.png" src="_images/ch08_fig05.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 8.5 </span><span class="caption-text"><strong>a.</strong> Reverse fault, striae and movement plane <span class="math notranslate nohighlight">\(M\)</span>. <strong>b.</strong> Representation of <strong>a</strong> on a lower hemisphere equal area stereonet. Modified from Marshak and Mitra (1988).</span><a class="headerlink" href="#ch08-fig05" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>The displacement gradient tensor, <span class="math notranslate nohighlight">\(e_{ij}\)</span> of a population of <span class="math notranslate nohighlight">\(n\)</span> small faults with poles vectors, <span class="math notranslate nohighlight">\(p_i\)</span>, and slip vectors, <span class="math notranslate nohighlight">\(u_i\)</span>, is given by (Allmendinger et al., 2012):</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq24">
<span class="eqno">(8.24)<a class="headerlink" href="#equation-ch08-eq24" title="Permalink to this equation">#</a></span>\[
e_{ij}=\frac{\sum_{i=1}^{n}\left(M_{g} u_{i} p_{j}\right)}{V}
\]</div>
<p>where <span class="math notranslate nohighlight">\(M_g\)</span> is the geometric moment and <span class="math notranslate nohighlight">\(V\)</span> is the volume of the region being deformed. As discussed in <span class="xref myst">Section 8.3</span>, we can decompose this equation to yield the infinitesimal strain and rotation tensors:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq25">
<span class="eqno">(8.25)<a class="headerlink" href="#equation-ch08-eq25" title="Permalink to this equation">#</a></span>\[
e_{i j}=\varepsilon_{i j}+\omega_{i j}=\frac{M_{g}\left(u_{i} p_{j}+u_{j} p_{i}\right)}{2 V}+\frac{M_{g}\left(u_{i} p_{j}-u_{j} p_{i}\right)}{2 V}
\]</div>
<p>Because <span class="math notranslate nohighlight">\(M_g/2V\)</span> is a scalar, the orientations of the principal axes of infinitesimal strain are identical to the principal axes of the symmetric tensor <span class="math notranslate nohighlight">\((u_i p_j+u_j p_i)\)</span>, which are just a function of the fault planes and striae orientations. The <strong>P</strong> and <strong>T</strong> axes are therefore a simple, direct representation of fault geometry and the orientation and sense of slip (Allmendinger et al., 1989).</p>
<p>The function <a class="reference external" href="https://github.com/nfcd/compGeo/blob/master/source/functions/pt_axes.py">pt_axes</a> computes and plots the <strong>P</strong> and <strong>T</strong> axes from the orientation of several faults and their slip vectors:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="kn">from</span> <span class="nn">compgeo.cart_to_sph</span> <span class="kn">import</span> <span class="n">cart_to_sph</span>
<span class="kn">from</span> <span class="nn">compgeo.zero_twopi</span> <span class="kn">import</span> <span class="n">zero_twopi</span>
<span class="kn">from</span> <span class="nn">compgeo.sph_to_cart</span> <span class="kn">import</span> <span class="n">sph_to_cart</span>
<span class="kn">from</span> <span class="nn">compgeo.stereonet</span> <span class="kn">import</span> <span class="n">stereonet</span>
<span class="kn">from</span> <span class="nn">compgeo.great_circle</span> <span class="kn">import</span> <span class="n">great_circle</span>
<span class="kn">from</span> <span class="nn">compgeo.st_coord_line</span> <span class="kn">import</span> <span class="n">st_coord_line</span>
<span class="kn">from</span> <span class="nn">compgeo.pole</span> <span class="kn">import</span> <span class="n">pole_from_plane</span>


<span class="k">def</span> <span class="nf">pt_axes</span><span class="p">(</span><span class="n">fault</span><span class="p">,</span><span class="n">slip</span><span class="p">,</span><span class="n">sense</span><span class="p">,</span> <span class="n">fpsv</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    pt_axes computes the P and T axes from the orientation</span>
<span class="sd">    of several fault planes and their slip vectors. Results</span>
<span class="sd">    are plotted in an equal area stereonet</span>

<span class="sd">    USE: P,T,senseC,fig,ax = pt_axes(fault,slip,sense)</span>

<span class="sd">    fault = nfaults x 2 vector with strikes and dips of</span>
<span class="sd">        faults</span>
<span class="sd">    slip = nfaults x 2 vector with trend and plunge of</span>
<span class="sd">        slip vectors</span>
<span class="sd">    sense = nfaults x 1 vector with sense of faults</span>
<span class="sd">    fpsv = A flag to tell wether the fault plane and</span>
<span class="sd">        slip vector are plotted (1) or not</span>
<span class="sd">    P = nfaults x 2 vector with trend and plunge of P axes</span>
<span class="sd">    T = nfaults x 2 vector with trend and plunge of T axes</span>
<span class="sd">    senseC = nfaults x 1 vector with corrected sense of slip</span>

<span class="sd">    fig and ax are handles to the figure and axes</span>

<span class="sd">    NOTE: Input/Output angles are in radians</span>

<span class="sd">    Python function based on the Matlab function</span>
<span class="sd">    PTAxes in Allmendinger et al. (2012)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="c1"># Initialize some vectors</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">fault</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">fault</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">senseC</span> <span class="o">=</span> <span class="n">sense</span>

    <span class="c1"># For all faults</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">fault</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
        
        <span class="c1"># Direction cosines of pole to fault and slip vector</span>
        <span class="n">trd</span><span class="p">,</span> <span class="n">plg</span> <span class="o">=</span> <span class="n">pole_from_plane</span><span class="p">(</span><span class="n">fault</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">fault</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sph_to_cart</span><span class="p">(</span><span class="n">trd</span><span class="p">,</span> <span class="n">plg</span><span class="p">)</span>
        <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sph_to_cart</span><span class="p">(</span><span class="n">slip</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">slip</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># Compute u(i)*p(j) + u(j)*p(i)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">eps</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">u</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">+</span><span class="n">u</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        
        <span class="c1"># Compute orientations of principal axes of strain</span>
        <span class="c1"># Here we use the function eigh</span>
        <span class="n">_</span><span class="p">,</span><span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">eps</span><span class="p">)</span>
        
        <span class="c1"># P orientation</span>
        <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cart_to_sph</span><span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="n">V</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">zero_twopi</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">pi</span><span class="p">)</span>
            <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        
        <span class="c1"># T orientation</span>
        <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cart_to_sph</span><span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">V</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> 
        <span class="k">if</span> <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">zero_twopi</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">pi</span><span class="p">)</span>
            <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        
        <span class="c1"># Determine 3rd component of pole cross product slip</span>
        <span class="n">cross</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># Use cross and first character in sense to</span>
        <span class="c1"># determine if kinematic axes should be switched</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="s2">&quot;p&quot;</span>
        <span class="k">if</span> <span class="n">sense</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;T&quot;</span> <span class="ow">or</span> <span class="n">sense</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span> 
            <span class="n">s2</span> <span class="o">=</span> <span class="s2">&quot;Y&quot;</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">sense</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;R&quot;</span> <span class="ow">or</span> <span class="n">sense</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">cross</span><span class="o">&gt;</span><span class="mf">0.0</span><span class="p">:</span>
            <span class="n">s2</span> <span class="o">=</span> <span class="s2">&quot;Y&quot;</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">sense</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;L&quot;</span> <span class="ow">or</span> <span class="n">sense</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;l&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">cross</span><span class="o">&lt;</span><span class="mf">0.0</span><span class="p">:</span> 
            <span class="n">s2</span> <span class="o">=</span> <span class="s2">&quot;Y&quot;</span>
        
        <span class="k">if</span> <span class="n">s2</span> <span class="o">==</span> <span class="s2">&quot;Y&quot;</span><span class="p">:</span>
            <span class="n">temp1</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">temp2</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp1</span>
            <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp2</span>
            
            <span class="k">if</span> <span class="n">cross</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span> 
                <span class="n">senseC</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;TL&quot;</span>
            
            <span class="k">if</span> <span class="n">cross</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">senseC</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;TR&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            
            <span class="k">if</span> <span class="n">cross</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">senseC</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;NR&quot;</span>
            
            <span class="k">if</span> <span class="n">cross</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">senseC</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;NL&quot;</span>

    <span class="c1"># Plot in equal area stereonet</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">stereonet</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">90</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span><span class="p">,</span><span class="mi">10</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># Plot P and T axes</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">fault</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
        
        <span class="k">if</span> <span class="n">fpsv</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            
            <span class="c1"># Plot fault</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">great_circle</span><span class="p">(</span><span class="n">fault</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">fault</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">path</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">path</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
            
            <span class="c1"># Plot slip vector (black circle)</span>
            <span class="n">xp</span><span class="p">,</span><span class="n">yp</span> <span class="o">=</span> <span class="n">st_coord_line</span><span class="p">(</span><span class="n">slip</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">slip</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span><span class="n">yp</span><span class="p">,</span><span class="s2">&quot;ko&quot;</span><span class="p">,</span><span class="s2">&quot;MarkerFaceColor&quot;</span><span class="p">,</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
        
        <span class="c1"># Plot P axis (blue circle)</span>
        <span class="n">xp</span><span class="p">,</span><span class="n">yp</span> <span class="o">=</span> <span class="n">st_coord_line</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span><span class="n">yp</span><span class="p">,</span><span class="s2">&quot;bo&quot;</span><span class="p">,</span><span class="s2">&quot;MarkerFaceColor&quot;</span><span class="p">,</span><span class="s2">&quot;b&quot;</span><span class="p">)</span>
        
        <span class="c1"># Plot T axis (red circle)</span>
        <span class="n">xp</span><span class="p">,</span><span class="n">yp</span> <span class="o">=</span> <span class="n">st_coord_line</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span><span class="n">yp</span><span class="p">,</span><span class="s2">&quot;ro&quot;</span><span class="p">,</span><span class="s2">&quot;MarkerFaceColor&quot;</span><span class="p">,</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">senseC</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s use this function to plot the <strong>P</strong> and <strong>T</strong> axes for a group of faults from the Central Andes in Northern Argentina. The file <a class="reference external" href="https://github.com/nfcd/compGeo/blob/master/source/data/ch8-1/jujuy.txt">jujuy.txt</a> contains the orientation (strike and dip) of the faults, and the orientation (trend and plunge) and sense of movement of the slip vectors (striae).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The file <a class="reference external" href="https://github.com/nfcd/compGeo/blob/master/source/data/ch8-1/jujuy.txt">jujuy.txt</a> is the same one included in the program <a class="reference external" href="https://www.rickallmendinger.net/faultkin">FaultKin</a> by Richard Allmendinger.</p>
</div>
<p>The notebook <a class="reference external" href="https://github.com/nfcd/compGeo/blob/master/source/notebooks/ch8-1.ipynb">ch8-1</a> shows how to do this:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import libraries</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">pi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

<span class="c1"># Import function pt_axes</span>
<span class="kn">from</span> <span class="nn">compgeo.pt_axes</span> <span class="kn">import</span> <span class="n">pt_axes</span>


<span class="c1"># Read the faults</span>
<span class="n">jujuy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="s2">&quot;data/ch8-1/jujuy.txt&quot;</span><span class="p">),</span>
                   <span class="n">usecols</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>

<span class="n">fault</span> <span class="o">=</span> <span class="n">jujuy</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">pi</span><span class="o">/</span><span class="mi">180</span>
<span class="n">slip</span> <span class="o">=</span> <span class="n">jujuy</span><span class="p">[:,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">*</span> <span class="n">pi</span><span class="o">/</span><span class="mi">180</span>

<span class="n">sense</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="s2">&quot;data/ch8-1/jujuy.txt&quot;</span><span class="p">),</span> 
                   <span class="n">usecols</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="s2">&quot;str&quot;</span><span class="p">)</span>

<span class="c1"># Compute P and T axes and plot them</span>
<span class="c1"># Don&#39;t plot the faults and slip vectors</span>
<span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">senseC</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">pt_axes</span><span class="p">(</span><span class="n">fault</span><span class="p">,</span> <span class="n">slip</span><span class="p">,</span> <span class="n">sense</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ch08_strain_69_0.png" src="_images/ch08_strain_69_0.png" />
</div>
</div>
<p>Here, the overall shortening direction given by the <strong>P</strong> axes (blue dots) is about E-W. From the <strong>P</strong> and <strong>T</strong> axes, it is possible to calculate a moment tensor summation and the kinematic axes, which define two nodal planes separating the regions of extension (<strong>T</strong> axes) and shortening (<strong>P</strong> axes). The regions of extension are typically shaded, and so the diagram looks like a beach ball (<a class="reference internal" href="#ch08-fig04"><span class="std std-numref">Figure 8.4</span></a>c). Beach ball diagrams are also used to display the focal mechanisms of earthquakes, where P-waves first arrivals pushing the ground up are marked as <strong>T</strong> axes, and those pushing the ground down are marked as <strong>P</strong> axes. We leave the moment tensor summation for the Exercises section.</p>
</section>
<section id="d-strain-from-gps-data">
<span id="ch08-3-2-2"></span><h4><span class="section-number">8.3.2.2. </span>2D strain from GPS data<a class="headerlink" href="#d-strain-from-gps-data" title="Permalink to this headline">#</a></h4>
<p>The global positioning system (GPS) has revolutionized Earth sciences by providing geoscientists with real time monitoring of active deformation. Continuous GPS measurements provide mm resolution of the displacement of stations. Because the changes in distance between stations is very small (10s of mm) relative to the distance between stations (10s of km), the strains measured by GPS networks are infinitesimal. <a class="reference internal" href="#ch08-fig06"><span class="std std-numref">Figure 8.6</span></a> shows this problem in two dimensions:</p>
<figure class="align-default" id="ch08-fig06">
<a class="reference internal image-reference" href="_images/ch08_fig06.png"><img alt="_images/ch08_fig06.png" src="_images/ch08_fig06.png" style="width: 450px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 8.6 </span><span class="caption-text">Three points in an initial configuration <span class="math notranslate nohighlight">\(\textbf{X}\)</span> move along non-parallel vectors <span class="math notranslate nohighlight">\(\textbf{u}\)</span> to a final configuration <span class="math notranslate nohighlight">\(\textbf{x}\)</span>, resulting in strain. Modified from Allmendinger et al. (2012).</span><a class="headerlink" href="#ch08-fig06" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>If the strain is homogeneous, the displacement of the stations is expressed by the following equation:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq26">
<span class="eqno">(8.26)<a class="headerlink" href="#equation-ch08-eq26" title="Permalink to this equation">#</a></span>\[
u_{i}=t_{i}+e_{i j} X_{j}
\]</div>
<p>where <span class="math notranslate nohighlight">\(t_i\)</span> is the translation vector and <span class="math notranslate nohighlight">\(e_{ij}\)</span> is the displacement gradient tensor. In matrix form, this equation can be written as:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq27">
<span class="eqno">(8.27)<a class="headerlink" href="#equation-ch08-eq27" title="Permalink to this equation">#</a></span>\[\begin{split}
\left[\begin{array}{c}{ }^{1} u_1 \\ { }^{1} u_{2} \\ { }^{2} u_{1} \\ { }^{2} u_{2} \\ \cdots \\ \cdots \\ { }^{n} u_{1} \\ { }^{n} u_{2}\end{array}\right]=\left[\begin{array}{cccccc}1 &amp; 0 &amp; { }^{1} X_{1} &amp; { }^{1} X_{2} &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 &amp; { }^{1} X_{1} &amp; { }^{1} X_{2} \\ 1 &amp; 0 &amp; { }^{2} X_{1} &amp; { }^{2} X_{2} &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 &amp; { }^{2} X_{1} &amp; { }^{2} X_{2} \\ \cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots \\ \cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots \\ 1 &amp; 0 &amp; { }^{n} X_{1} &amp; { }^{n} X_{2} &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 &amp; { }^{n} X_{1} &amp; { }^{n} X_{2}\end{array}\right]\left[\begin{array}{l}t_{1} \\ t_{2} \\ e_{11} \\ e_{12} \\ e_{21} \\ e_{22}\end{array}\right]
\end{split}\]</div>
<p>where the superscripts 1 to <span class="math notranslate nohighlight">\(n\)</span> refer to the stations. The column vector to the right of Eq. <a class="reference internal" href="#equation-ch08-eq27">(8.27)</a> contains the unknowns, which are the two components of the translation vector (<span class="math notranslate nohighlight">\(t_1\)</span> and <span class="math notranslate nohighlight">\(t_2\)</span>) and the four components of the displacement gradient tensor (<span class="math notranslate nohighlight">\(e_{11}\)</span>, <span class="math notranslate nohighlight">\(e_{12}\)</span>, <span class="math notranslate nohighlight">\(e_{21}\)</span> and <span class="math notranslate nohighlight">\(e_{22}\)</span>). Therefore, in 2D there are 6 unknowns, and since each station delivers 2 equations, we need a minimum of 3 non-colinear stations to determine the strain ellipse.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In 3D there are 12 unknowns and each station delivers 3 equations. Therefore, we need a minimum of 4 non-colinear stations to determine the strain ellipsoid.</p>
</div>
<p>Notice that Eq. <a class="reference internal" href="#equation-ch08-eq27">(8.27)</a> is written not just for 3 stations but for <span class="math notranslate nohighlight">\(n\)</span> stations. If there are more than 3 stations in 2D (or 4 stations in 3D), the system is overdetermined (more equations than unknowns), and we can use the extra information to assess the uncertainties of the model parameters.</p>
<p>The solution to Eq. <a class="reference internal" href="#equation-ch08-eq27">(8.27)</a> is a classical application of inverse theory, specifically the solution of the linear least-squares problem (Press et al., 1986). This problem has the form:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq28">
<span class="eqno">(8.28)<a class="headerlink" href="#equation-ch08-eq28" title="Permalink to this equation">#</a></span>\[
\mathbf{y}=\mathbf{M} \mathbf{x}
\]</div>
<p>where <strong>y</strong> is the vector with known displacements, <strong>M</strong> is the matrix with the location of the stations (this matrix is known as the design matrix), and <strong>x</strong> is the vector with the unknowns. To solve for <strong>x</strong>, <strong>y</strong> is multiplied by the inverse of <strong>M</strong>:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq29">
<span class="eqno">(8.29)<a class="headerlink" href="#equation-ch08-eq29" title="Permalink to this equation">#</a></span>\[
\mathbf{x}=\mathbf{M}^{-1} \mathbf{y}
\]</div>
<p>In Matlab or Python, there are routines specifically designed to solve this problem. We use the function <a class="reference external" href="https://github.com/nfcd/compGeo/blob/master/source/functions/lscov.py">lscov</a> by Paul Müller to solve this problem.</p>
<p>There are three main strategies to compute the strain from a network of stations: i. To calculate the strain on triangular cells whose vertices are defined by the stations (Delaunay triangulation), ii. To calculate the strain on a regular grid of cells, using the stations within a radius, <span class="math notranslate nohighlight">\(r\)</span>, from the center of each cell (nearest neighbor method), or iii. To calculate the strain on a regular grid of cells, using all the stations weighted by their distance to the center of each cell (distance weighted method; Cardozo and Allmendinger; 2009). In this last case, the weighting factor is given by:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq30">
<span class="eqno">(8.30)<a class="headerlink" href="#equation-ch08-eq30" title="Permalink to this equation">#</a></span>\[
W=\exp \left[\frac{-d^{2}}{2 \alpha^{2}}\right]
\]</div>
<p>where <span class="math notranslate nohighlight">\(d\)</span> is the distance from the station to the center of the cell, and <span class="math notranslate nohighlight">\(\alpha\)</span> is a constant that specifies how the impact of a station decays with distance. A larger value of <span class="math notranslate nohighlight">\(\alpha\)</span> smooths out local variations.</p>
<p>The function <a class="reference external" href="https://github.com/nfcd/compGeo/blob/master/source/functions/grid_strain.py">grid_strain</a> computes and plots the infinitesimal strain of a network of GPS stations. Notice that after computing the displacement gradient for each cell, we use the function <code class="docutils literal notranslate"><span class="pre">inf_strain</span></code> to compute the strain:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib.colors</span> <span class="k">as</span> <span class="nn">mcolors</span>
<span class="kn">from</span> <span class="nn">matplotlib.patches</span> <span class="kn">import</span> <span class="n">Polygon</span>
<span class="kn">from</span> <span class="nn">matplotlib.collections</span> <span class="kn">import</span> <span class="n">PatchCollection</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">Delaunay</span>

<span class="kn">from</span> <span class="nn">compgeo.lscov</span> <span class="kn">import</span> <span class="n">lscov</span>
<span class="kn">from</span> <span class="nn">compgeo.inf_strain</span> <span class="kn">import</span> <span class="n">inf_strain</span>


<span class="k">def</span> <span class="nf">grid_strain</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="n">disp</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">par</span><span class="p">,</span><span class="n">plotpar</span><span class="p">,</span><span class="n">plotst</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    grid_strain computes the infinitesimal strain of a network</span>
<span class="sd">    of stations with displacements in x (east) and y (north).</span>
<span class="sd">    Strain in z is assumed to be zero (plane strain)</span>

<span class="sd">    USE: cent,eps,ome,pstrain,rotc,fig,ax = </span>
<span class="sd">        grid_strain(pos,disp,k,par,plotpar,plotst)</span>

<span class="sd">    pos = nstations x 2 matrix with x (east) and y (north)</span>
<span class="sd">        positions of stations in meters</span>
<span class="sd">    disp = nstations x 2 matrix with x (east) and y (north)</span>
<span class="sd">        displacements of stations in meters</span>
<span class="sd">    k = Type of computation: Delaunay (k = 0), nearest</span>
<span class="sd">        neighbor (k = 1), or distance weighted (k = 2)</span>
<span class="sd">    par = Parameters for nearest neighbor or distance</span>
<span class="sd">        weighted computation. If Delaunay (k = 0), enter</span>
<span class="sd">        a scalar corresponding to the minimum internal</span>
<span class="sd">        angle of a triangle valid for computation.</span>
<span class="sd">        If nearest neighbor (k = 1), input a 1 x 3 vector</span>
<span class="sd">        with grid spacing, number of nearest neighbors,</span>
<span class="sd">        and maximum distance to neighbors. If distance</span>
<span class="sd">        weighted (k = 2), input a 1 x 2 vector with grid</span>
<span class="sd">        spacing and distance weighting factor alpha</span>
<span class="sd">    plotpar = Parameter to color the cells: Max elongation</span>
<span class="sd">        (plotpar = 0), minimum elongation</span>
<span class="sd">        (plotpar = 1), rotation (plotpar = 2),</span>
<span class="sd">        or dilatation (plotpar = 3)</span>
<span class="sd">    plotst = A flag to plot the stations (1) or not (0)</span>
<span class="sd">    cent = ncells x 2 matrix with x and y positions of </span>
<span class="sd">        cells centroids</span>
<span class="sd">    eps = 3 x 3 x ncells array  with strain tensors of</span>
<span class="sd">        the cells</span>
<span class="sd">    ome = 3 x 3 x ncells array with rotation tensors of</span>
<span class="sd">        the cells</span>
<span class="sd">    pstrain = 3 x 3 x ncells array with magnitude and</span>
<span class="sd">        orientation of principal strains of</span>
<span class="sd">        the cells</span>
<span class="sd">    rotc = ncells x 3 matrix with rotation components</span>
<span class="sd">        of cells</span>

<span class="sd">    fig and ax are handles to the figure and axes</span>

<span class="sd">    NOTE: Input/Output angles are in radians. Output</span>
<span class="sd">        azimuths are given with respect to North</span>
<span class="sd">        pos, disp, grid spacing, max. distance to</span>
<span class="sd">        neighbors, and alpha should be in meters</span>

<span class="sd">    Python function translated from the Matlab function</span>
<span class="sd">    GridStrain in Allmendinger et al. (2012)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    
    <span class="c1"># If Delaunay</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Indexes of triangles vertices</span>
        <span class="c1"># Use function Delaunay</span>
        <span class="n">tri</span> <span class="o">=</span> <span class="n">Delaunay</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="n">tri</span><span class="o">.</span><span class="n">simplices</span>
        
        <span class="c1"># Number of cells</span>
        <span class="n">ncells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="c1"># Number of stations per cell = 3</span>
        <span class="n">nstat</span> <span class="o">=</span> <span class="mi">3</span>
        
        <span class="c1"># Centers of cells</span>
        <span class="n">cent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ncells</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncells</span><span class="p">):</span>
            
            <span class="c1"># Triangle vertices</span>
            <span class="n">v1x</span><span class="o">=</span><span class="n">pos</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">v2x</span><span class="o">=</span><span class="n">pos</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">v3x</span><span class="o">=</span><span class="n">pos</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">v1y</span><span class="o">=</span><span class="n">pos</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">v2y</span><span class="o">=</span><span class="n">pos</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">v3y</span><span class="o">=</span><span class="n">pos</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="mi">1</span><span class="p">]</span>
            
            <span class="c1"># Center of cell</span>
            <span class="n">cent</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">v1x</span> <span class="o">+</span> <span class="n">v2x</span> <span class="o">+</span> <span class="n">v3x</span><span class="p">)</span><span class="o">/</span><span class="mf">3.0</span>
            <span class="n">cent</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">v1y</span> <span class="o">+</span> <span class="n">v2y</span> <span class="o">+</span> <span class="n">v3y</span><span class="p">)</span><span class="o">/</span><span class="mf">3.0</span>
            
            <span class="c1"># Triangle internal angles</span>
            <span class="n">s1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">v3x</span><span class="o">-</span><span class="n">v2x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">v3y</span><span class="o">-</span><span class="n">v2y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">s2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">v1x</span><span class="o">-</span><span class="n">v3x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">v1y</span><span class="o">-</span><span class="n">v3y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">s3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">v2x</span><span class="o">-</span><span class="n">v1x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">v2y</span><span class="o">-</span><span class="n">v1y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">a1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">((</span><span class="n">v2x</span><span class="o">-</span><span class="n">v1x</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">v3x</span><span class="o">-</span><span class="n">v1x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">s3</span><span class="o">*</span><span class="n">s2</span><span class="p">)</span><span class="o">+</span>\
                <span class="p">(</span><span class="n">v2y</span><span class="o">-</span><span class="n">v1y</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">v3y</span><span class="o">-</span><span class="n">v1y</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">s3</span><span class="o">*</span><span class="n">s2</span><span class="p">))</span>
            <span class="n">a2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">((</span><span class="n">v3x</span><span class="o">-</span><span class="n">v2x</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">v1x</span><span class="o">-</span><span class="n">v2x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">s1</span><span class="o">*</span><span class="n">s3</span><span class="p">)</span><span class="o">+</span>\
                <span class="p">(</span><span class="n">v3y</span><span class="o">-</span><span class="n">v2y</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">v1y</span><span class="o">-</span><span class="n">v2y</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">s1</span><span class="o">*</span><span class="n">s3</span><span class="p">))</span>
            <span class="n">a3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">((</span><span class="n">v2x</span><span class="o">-</span><span class="n">v3x</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">v1x</span><span class="o">-</span><span class="n">v3x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">s1</span><span class="o">*</span><span class="n">s2</span><span class="p">)</span><span class="o">+</span>\
                <span class="p">(</span><span class="n">v2y</span><span class="o">-</span><span class="n">v3y</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">v1y</span><span class="o">-</span><span class="n">v3y</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">s1</span><span class="o">*</span><span class="n">s2</span><span class="p">))</span>
            
            <span class="c1"># If any of the internal angles is less than</span>
            <span class="c1"># specified minimum, invalidate triangle</span>
            <span class="k">if</span> <span class="n">a1</span> <span class="o">&lt;</span> <span class="n">par</span> <span class="ow">or</span> <span class="n">a2</span> <span class="o">&lt;</span> <span class="n">par</span> <span class="ow">or</span> <span class="n">a3</span> <span class="o">&lt;</span> <span class="n">par</span><span class="p">:</span>
                <span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    
    <span class="c1"># If nearest neighbor or distance weighted</span>
    <span class="k">else</span><span class="p">:</span>
        
        <span class="c1"># Construct grid</span>
        <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">pos</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">max</span><span class="p">(</span><span class="n">pos</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">pos</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">max</span><span class="p">(</span><span class="n">pos</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">cellsx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">xmax</span><span class="o">-</span><span class="n">xmin</span><span class="p">)</span><span class="o">/</span><span class="n">par</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">cellsy</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">ymax</span><span class="o">-</span><span class="n">ymin</span><span class="p">)</span><span class="o">/</span><span class="n">par</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">xgrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">xmin</span><span class="p">,(</span><span class="n">xmin</span><span class="o">+</span><span class="p">(</span><span class="n">cellsx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">par</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">par</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ygrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ymin</span><span class="p">,(</span><span class="n">ymin</span><span class="o">+</span><span class="p">(</span><span class="n">cellsy</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">par</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">par</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">XX</span><span class="p">,</span><span class="n">YY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xgrid</span><span class="p">,</span><span class="n">ygrid</span><span class="p">)</span>
        
        <span class="c1"># Number of cells</span>
        <span class="n">ncells</span> <span class="o">=</span> <span class="n">cellsx</span> <span class="o">*</span> <span class="n">cellsy</span>
        
        <span class="c1"># Number of stations per cell (nstat) and</span>
        <span class="c1"># other parameters</span>
        <span class="c1"># If nearest neighbor</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">nstat</span> <span class="o">=</span> <span class="n">par</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># max neighbors</span>
            <span class="n">sqmd</span> <span class="o">=</span> <span class="n">par</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="c1"># max squared distance</span>
        
        <span class="c1"># If distance weighted</span>
        <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">nstat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># all stations</span>
            <span class="n">dalpha</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">par</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">par</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># 2*alpha*alpha</span>
        
        <span class="c1"># Cells&quot; centers</span>
        <span class="n">cent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ncells</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cellsy</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cellsx</span><span class="p">):</span>
                <span class="n">cent</span><span class="p">[</span><span class="n">count</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">XX</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">XX</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mf">2.0</span>
                <span class="n">cent</span><span class="p">[</span><span class="n">count</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">YY</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">YY</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">])</span><span class="o">/</span><span class="mf">2.0</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="c1"># Initialize stations indexes for cells to -1</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">ncells</span><span class="p">,</span><span class="n">nstat</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">*-</span><span class="mi">1</span>
        
        <span class="c1"># Initialize weight matrix for distance weighted</span>
        <span class="n">wv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ncells</span><span class="p">,</span><span class="n">nstat</span><span class="o">*</span><span class="mi">2</span><span class="p">))</span>
        
        <span class="c1"># For all cells set stations indexes</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncells</span><span class="p">):</span>
            
            <span class="c1"># Initialize sq distances to -1.0</span>
            <span class="n">sds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nstat</span><span class="p">)</span><span class="o">*-</span><span class="mf">1.0</span>
            
            <span class="c1"># For all stations</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
                
                <span class="c1"># sq distance from cell center to station</span>
                <span class="n">dx</span> <span class="o">=</span> <span class="n">cent</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">dy</span> <span class="o">=</span> <span class="n">cent</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">sd</span> <span class="o">=</span> <span class="n">dx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">dy</span><span class="o">**</span><span class="mi">2</span>
                
                <span class="c1"># If nearest neighbor</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    
                    <span class="c1"># If within the max sq distance</span>
                    <span class="k">if</span> <span class="n">sd</span> <span class="o">&lt;=</span> <span class="n">sqmd</span><span class="p">:</span>
                        <span class="n">minsd</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">sds</span><span class="p">)</span>
                        <span class="n">mini</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">sds</span><span class="p">)</span>
                        
                        <span class="c1"># If less than max neighbors</span>
                        <span class="k">if</span> <span class="n">minsd</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>
                            <span class="n">sds</span><span class="p">[</span><span class="n">mini</span><span class="p">]</span> <span class="o">=</span> <span class="n">sd</span>
                            <span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">mini</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
                        
                        <span class="c1"># If max neighbors</span>
                        <span class="k">else</span><span class="p">:</span>
                            
                            <span class="c1"># If sq distance is less </span>
                            <span class="c1"># than neighbors max sq distance</span>
                            <span class="n">maxsd</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">sds</span><span class="p">)</span>
                            <span class="n">maxi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">sds</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">sd</span> <span class="o">&lt;</span> <span class="n">maxsd</span><span class="p">:</span>
                                <span class="n">sds</span><span class="p">[</span><span class="n">maxi</span><span class="p">]</span> <span class="o">=</span> <span class="n">sd</span>
                                <span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">maxi</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
                
                <span class="c1"># If distance weighted</span>
                <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    
                    <span class="c1"># All stations indexes</span>
                    <span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nstat</span><span class="p">)</span>
                    
                    <span class="c1"># Weight factor</span>
                    <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">sd</span><span class="o">/</span><span class="n">dalpha</span><span class="p">)</span>
                    <span class="n">wv</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span>
                    <span class="n">wv</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span>

    <span class="c1"># Initialize arrays</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nstat</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nstat</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span> 
    <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">ncells</span><span class="p">))</span>
    <span class="n">ome</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">ncells</span><span class="p">))</span> 
    <span class="n">pstrain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">ncells</span><span class="p">))</span>
    <span class="n">rotc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ncells</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span> 

    <span class="c1"># For each cell</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncells</span><span class="p">):</span>
        
        <span class="c1"># If required minimum number of stations</span>
        <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            
            <span class="c1"># Displacements column vector y</span>
            <span class="c1"># and design matrix M. X1 = North, X2 = East</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nstat</span><span class="p">):</span>
                <span class="n">ic</span> <span class="o">=</span> <span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
                <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">disp</span><span class="p">[</span><span class="n">ic</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">disp</span><span class="p">[</span><span class="n">ic</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="n">pos</span><span class="p">[</span><span class="n">ic</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">pos</span><span class="p">[</span><span class="n">ic</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]</span>
                <span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="n">pos</span><span class="p">[</span><span class="n">ic</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">pos</span><span class="p">[</span><span class="n">ic</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>
            
            <span class="c1"># Find x using function lscov</span>
            <span class="c1"># If Delaunay or nearest neighbor</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">lscov</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
            
            <span class="c1"># If distance weighted</span>
            <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">lscov</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">wv</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span>
            
            <span class="c1"># Displacement gradient tensor</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">e</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">e</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span>
            
            <span class="c1"># Compute strain</span>
            <span class="n">eps</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">],</span><span class="n">ome</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">],</span><span class="n">pstrain</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">],</span>\
                <span class="n">rotc</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span><span class="n">_</span> <span class="o">=</span> <span class="n">inf_strain</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

    <span class="c1"># Variable to plot</span>
    <span class="c1"># If maximum principal strain</span>
    <span class="k">if</span> <span class="n">plotpar</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">vp</span> <span class="o">=</span> <span class="n">pstrain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span>
        <span class="n">lcb</span> <span class="o">=</span> <span class="s2">&quot;emax&quot;</span>
    
    <span class="c1"># If minimum principal strain</span>
    <span class="k">elif</span> <span class="n">plotpar</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">vp</span> <span class="o">=</span> <span class="n">pstrain</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span>
        <span class="n">lcb</span> <span class="o">=</span> <span class="s2">&quot;emin&quot;</span>
    
    <span class="c1"># If rotation: </span>
    <span class="c1"># For plane strain, rotation = rotc(3)</span>
    <span class="k">elif</span> <span class="n">plotpar</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">vp</span> <span class="o">=</span> <span class="n">rotc</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">pi</span>
        <span class="n">lcb</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;Rotation ($\circ$)&quot;</span>
    
    <span class="c1"># If dilatation</span>
    <span class="k">elif</span> <span class="n">plotpar</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">vp</span> <span class="o">=</span> <span class="n">pstrain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span><span class="o">+</span><span class="n">pstrain</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span><span class="o">+</span><span class="n">pstrain</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span>
        <span class="n">lcb</span> <span class="o">=</span> <span class="s2">&quot;dilatation&quot;</span>

    <span class="c1"># Make a figure</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mf">7.5</span><span class="p">))</span>

    <span class="c1"># Patches and colors for cells</span>
    <span class="n">patches</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Fill cells patches and colors</span>
    <span class="c1"># If Delaunay</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncells</span><span class="p">):</span>
            
            <span class="c1"># If minimum number of stations</span>
                <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">xpyp</span> <span class="o">=</span> <span class="p">[[</span><span class="n">pos</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">],</span><span class="n">pos</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">]],</span>\
                        <span class="p">[</span><span class="n">pos</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="mi">0</span><span class="p">],</span><span class="n">pos</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">]],</span>\
                        <span class="p">[</span><span class="n">pos</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="mi">0</span><span class="p">],</span><span class="n">pos</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="mi">1</span><span class="p">]]]</span>
                    
                    <span class="c1"># length in km</span>
                    <span class="n">xpyp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">xpyp</span><span class="p">,</span><span class="mf">1e3</span><span class="p">)</span>
                    <span class="n">polygon</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">xpyp</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                    <span class="n">patches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span>
                    <span class="n">colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    
    <span class="c1"># If nearest neighbor or distance weighted</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cellsy</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cellsx</span><span class="p">):</span>
                
                <span class="c1"># If minimum number of stations</span>
                <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">inds</span><span class="p">[</span><span class="n">count</span><span class="p">,:])</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">xpyp</span> <span class="o">=</span> <span class="p">[[</span><span class="n">XX</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span><span class="n">YY</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]],[</span><span class="n">XX</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">YY</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span>\
                        <span class="p">[</span><span class="n">XX</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">YY</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]],[</span><span class="n">XX</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">],</span><span class="n">YY</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]]]</span>
                    
                    <span class="c1"># length in km</span>
                    <span class="n">xpyp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">xpyp</span><span class="p">,</span><span class="mf">1e3</span><span class="p">)</span>
                    <span class="n">polygon</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">xpyp</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                    <span class="n">patches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span>
                    <span class="n">colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vp</span><span class="p">[</span><span class="n">count</span><span class="p">])</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Collect cells patches</span>
    <span class="n">pcoll</span> <span class="o">=</span> <span class="n">PatchCollection</span><span class="p">(</span><span class="n">patches</span><span class="p">)</span>
    
    <span class="c1"># Cells colors</span>
    <span class="n">pcoll</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">colors</span><span class="p">))</span>
    
    <span class="c1"># Color map is blue to red</span>
    <span class="n">pcoll</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="s2">&quot;bwr&quot;</span><span class="p">)</span>
    
    <span class="c1"># Positive values are red, negative are</span>
    <span class="c1"># blue and zero is white</span>
    <span class="n">vmin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">vp</span><span class="p">)</span> 
    <span class="n">vmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">vp</span><span class="p">)</span>
    <span class="n">norm</span><span class="o">=</span><span class="n">mcolors</span><span class="o">.</span><span class="n">TwoSlopeNorm</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span><span class="n">vcenter</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
    <span class="n">pcoll</span><span class="o">.</span><span class="n">set_norm</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>

    <span class="c1"># Draw cells</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">pcoll</span><span class="p">)</span>

    <span class="c1"># Plot stations</span>
    <span class="k">if</span> <span class="n">plotst</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pos</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mf">1e-3</span><span class="p">,</span><span class="n">pos</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mf">1e-3</span><span class="p">,</span><span class="s2">&quot;k.&quot;</span><span class="p">,</span><span class="n">markersize</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> 

    <span class="c1"># Axes</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;equal&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;x (km)&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;y (km)&quot;</span><span class="p">)</span>

    <span class="c1"># Color bar with nice ticks</span>
    <span class="n">intv</span> <span class="o">=</span> <span class="p">(</span><span class="n">vmax</span><span class="o">-</span><span class="n">vmin</span><span class="p">)</span><span class="o">*</span><span class="mf">0.25</span>
    <span class="n">ticks</span><span class="o">=</span><span class="p">[</span><span class="n">vmin</span><span class="p">,</span><span class="n">vmin</span><span class="o">+</span><span class="n">intv</span><span class="p">,</span><span class="n">vmin</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">intv</span><span class="p">,</span><span class="n">vmin</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">intv</span><span class="p">,</span><span class="n">vmax</span><span class="p">]</span>
    <span class="n">lticks</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">{:.2e}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ticks</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>\
        <span class="s2">&quot;</span><span class="si">{:.2e}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ticks</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="s2">&quot;</span><span class="si">{:.2e}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ticks</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>\
        <span class="s2">&quot;</span><span class="si">{:.2e}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ticks</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span><span class="s2">&quot;</span><span class="si">{:.2e}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ticks</span><span class="p">[</span><span class="mi">4</span><span class="p">])]</span>
    <span class="n">cbar</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">pcoll</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">lcb</span><span class="p">,</span> <span class="n">ticks</span><span class="o">=</span><span class="n">ticks</span><span class="p">)</span>
    <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="n">lticks</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cent</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">ome</span><span class="p">,</span> <span class="n">pstrain</span><span class="p">,</span> <span class="n">rotc</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s use this function to compute the infinitesimal rotation in Tibet and the Himalaya. The file <a class="reference external" href="https://github.com/nfcd/compGeo/blob/master/source/data/ch8-2/tibet.txt">tibet.txt</a> contains the UTM, east and west, coordinates of GPS stations in the Tibetan Plateau region and their displacements in meters (from Zhang et al., 2004). The notebook <a class="reference external" href="https://github.com/nfcd/compGeo/blob/master/source/notebooks/ch8-2.ipynb">ch8-2</a> shows the solution to this problem using the Delaunay, nearest neighbor, and distance weighted methods.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">pi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

<span class="c1"># Import function grid_strain</span>
<span class="kn">from</span> <span class="nn">compgeo.grid_strain</span> <span class="kn">import</span> <span class="n">grid_strain</span>


<span class="c1"># Load Zhang et al. GPS data from the Tibetan plateau</span>
<span class="c1"># load x, y coordinates and displacements</span>
<span class="n">tibet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="s2">&quot;data/ch8-2/tibet.txt&quot;</span><span class="p">))</span>
<span class="n">pos</span> <span class="o">=</span> <span class="n">tibet</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="n">disp</span> <span class="o">=</span> <span class="n">tibet</span><span class="p">[:,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> 

<span class="c1"># Rotation from Delaunay triangulation, plot stations</span>
<span class="n">par</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">pi</span><span class="o">/</span><span class="mi">180</span> <span class="c1">#Minimum internal angle of triangles</span>
<span class="n">cent</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">ome</span><span class="p">,</span> <span class="n">pstrain</span><span class="p">,</span> <span class="n">rotc</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">grid_strain</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">disp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">par</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ch08_strain_86_0.png" src="_images/ch08_strain_86_0.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Rotation from nearest neighbor </span>
<span class="c1"># Grid spacing = 75 km, neighbors 6, </span>
<span class="c1"># max. distance = 150 km, plot stations</span>
<span class="n">par</span> <span class="o">=</span> <span class="p">[</span><span class="mf">75e3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mf">150e3</span><span class="p">]</span>
<span class="n">cent</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">ome</span><span class="p">,</span> <span class="n">pstrain</span><span class="p">,</span> <span class="n">rotc</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">grid_strain</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">disp</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">par</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ch08_strain_87_0.png" src="_images/ch08_strain_87_0.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Rotation from distance Weighted </span>
<span class="c1"># Grid spacing = 75 km, alpha = 150 km, plot stations</span>
<span class="n">par</span> <span class="o">=</span> <span class="p">[</span><span class="mf">75e3</span><span class="p">,</span><span class="mf">150e3</span><span class="p">]</span>
<span class="n">cent</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">ome</span><span class="p">,</span> <span class="n">pstrain</span><span class="p">,</span> <span class="n">rotc</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">grid_strain</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">disp</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">par</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ch08_strain_88_0.png" src="_images/ch08_strain_88_0.png" />
</div>
</div>
<p>Given the uneven distribution of the stations, the distance weighted method is perhaps the best representation of the infinitesimal strain. The rotation is about a downward vertical axis. The GPS-based rotation shows large coherent domains of clockwise (positive) and counterclockwise (negative) rotation. Interestingly enough, these domains are consistent with the permanent, long-term deformation of this region (Allmendinger et al., 2007).</p>
</section>
</section>
</section>
<section id="finite-strain">
<span id="ch08-4"></span><h2><span class="section-number">8.4. </span>Finite strain<a class="headerlink" href="#finite-strain" title="Permalink to this headline">#</a></h2>
<p>When deformations are large, the initial and final states are not identical:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq31">
<span class="eqno">(8.31)<a class="headerlink" href="#equation-ch08-eq31" title="Permalink to this equation">#</a></span>\[
d X_{i} \neq d x_{i} \quad \text { and } \quad \frac{\partial u_{i}}{\partial X_{i}} \neq \frac{\partial u_{i}}{\partial x_{i}}
\]</div>
<p>and therefore, we need to use all the tensors in <a class="reference internal" href="#ch08-tab01"><span class="std std-numref">Table 8.1</span></a>.</p>
<p>The mathematics of finite strain is quite involved (e.g. Means, 1976; Allmendinger et al., 2012) and we will not cover it in detail here. Rather, we will focus on the main tensors required to compute finite strain. We start with the finite strain tensor in the undeformed configuration:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq32">
<span class="eqno">(8.32)<a class="headerlink" href="#equation-ch08-eq32" title="Permalink to this equation">#</a></span>\[
E_{i j}=\frac{1}{2}\left[\frac{\partial u_{i}}{\partial X_{j}}+\frac{\partial u_{j}}{\partial X_{i}}+\frac{\partial u_{k}}{\partial X_{i}} \frac{\partial u_{k}}{\partial X_{j}}\right]=\frac{1}{2}\left[e_{i j}+e_{j i}+e_{k i} e_{k j}\right]
\]</div>
<p>where <span class="math notranslate nohighlight">\(E_{ij}\)</span> is known as the <em>Lagrangian finite strain tensor</em>. Similarly, we can compute the finite strain tensor in the deformed configuration:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq33">
<span class="eqno">(8.33)<a class="headerlink" href="#equation-ch08-eq33" title="Permalink to this equation">#</a></span>\[
\bar{E}_{i j}=\frac{1}{2}\left[\frac{\partial u_{i}}{\partial x_{j}}+\frac{\partial u_{j}}{\partial x_{i}}-\frac{\partial u_{k}}{\partial x_{i}} \frac{\partial u_{k}}{\partial x_{j}}\right]=\frac{1}{2}\left[\bar{e}_{i j}+\bar{e}_{j i}-\bar{e}_{k i} \bar{e}_{k j}\right]
\]</div>
<p>where <span class="math notranslate nohighlight">\(\bar{E}_{i j}\)</span> is known as the *Eulerian finite strain tensor.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We use an upper bar to denote tensors in the deformed configuration, e.g. <span class="math notranslate nohighlight">\(\bar{e}_{ij}\)</span> and <span class="math notranslate nohighlight">\(\bar{E}_{ij}\)</span>.</p>
</div>
<p>Notice that Eqs. <a class="reference internal" href="#equation-ch08-eq29">(8.29)</a> and <a class="reference internal" href="#equation-ch08-eq30">(8.30)</a> are similar to Eq. <a class="reference internal" href="#equation-ch08-eq15">(8.15)</a> for the infinitesimal strain tensor, but with an extra term (<span class="math notranslate nohighlight">\(e_{k i} e_{k j}\)</span> or <span class="math notranslate nohighlight">\(\bar{e}_{k i} \bar{e}_{k j}\)</span>).</p>
<p>From the deformation gradient <span class="math notranslate nohighlight">\(\mathbf{F}\)</span>, we can also compute deformation tensors. In the undeformed configuration:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq34">
<span class="eqno">(8.34)<a class="headerlink" href="#equation-ch08-eq34" title="Permalink to this equation">#</a></span>\[
C_{i j}=\frac{\partial x_{k}}{\partial X_{i}} \frac{\partial x_{k}}{\partial X_{j}}=F_{k i} F_{k j}
\]</div>
<p>where <span class="math notranslate nohighlight">\(C_{ij}\)</span> is known as the <em>Green deformation tensor</em>. Similarly, for the deformed configuration:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq35">
<span class="eqno">(8.35)<a class="headerlink" href="#equation-ch08-eq35" title="Permalink to this equation">#</a></span>\[
\bar{C}_{i j}=\frac{\partial X_{k}}{\partial x_{i}} \frac{\partial X_{k}}{\partial x_{j}}=\bar{F}_{k i} \bar{F}_{k j}
\]</div>
<p>where <span class="math notranslate nohighlight">\(\bar{C}_{i j}\)</span> is known as the <em>Cauchy deformation tensor</em>.</p>
<p>The finite strain and deformation tensors are related. In the undeformed configuration:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq36">
<span class="eqno">(8.36)<a class="headerlink" href="#equation-ch08-eq36" title="Permalink to this equation">#</a></span>\[
E_{i j}=\frac{1}{2}\left(C_{i j}-\delta_{i j}\right) \quad \text { and } \quad C_{i j}=\delta_{i j}+2 E_{i j}
\]</div>
<p>and in the deformed configuration:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq37">
<span class="eqno">(8.37)<a class="headerlink" href="#equation-ch08-eq37" title="Permalink to this equation">#</a></span>\[
\bar{E}_{i j}=\frac{1}{2}\left(\delta_{i j}-\bar{C}_{i j}\right) \quad \text { and } \quad \bar{C}_{i j}=\delta_{i j}-2 \bar{E}_{i j}
\]</div>
<p>where <span class="math notranslate nohighlight">\(\delta_{ij}\)</span> is the Kronecker delta, a function that returns 1 if <span class="math notranslate nohighlight">\(i = j\)</span>, or 0 otherwise.</p>
<p>Thus, the finite strain tensors do not contain any more information than the deformation tensors, and viceversa. They are all symmetric tensors that have principal axes and can be represented by Mohr circles (see next section). From Eqs. <a class="reference internal" href="#equation-ch08-eq36">(8.36)</a> and <a class="reference internal" href="#equation-ch08-eq37">(8.37)</a>, it is clear that <span class="math notranslate nohighlight">\(E_{ij}\)</span> and <span class="math notranslate nohighlight">\(C_{ij}\)</span> have the same principal axes orientations. This is also the case for <span class="math notranslate nohighlight">\(\bar{E}_{ij}\)</span> and <span class="math notranslate nohighlight">\(\bar{C}_{ij}\)</span>. In addition these tensors are related to the quadratic elongation, <span class="math notranslate nohighlight">\(\lambda_i\)</span>, along the coordinate axes:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq38">
<span class="eqno">(8.38)<a class="headerlink" href="#equation-ch08-eq38" title="Permalink to this equation">#</a></span>\[
\lambda_{i}=C_{i i}=1+2 E_{i i}
\]</div>
<p>and:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq39">
<span class="eqno">(8.39)<a class="headerlink" href="#equation-ch08-eq39" title="Permalink to this equation">#</a></span>\[
\frac{1}{\lambda_{i}}=\bar{C}_{i i}=1-2 \bar{E}_{i i}
\]</div>
<p><a class="reference internal" href="#ch08-tab02"><span class="std std-numref">Table 8.2</span></a> shows the finite strain and deformation tensors for the deformation in <a class="reference internal" href="#ch08-fig02"><span class="std std-numref">Figure 8.2</span></a>.</p>
<table class="table" id="ch08-tab02">
<caption><span class="caption-number">Table 8.2 </span><span class="caption-text">Finite strain and deformation tensors for Figure 8.2.</span><a class="headerlink" href="#ch08-tab02" title="Permalink to this table">#</a></caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Undeformed</p></td>
<td><p><span class="math notranslate nohighlight">\(E_{ij}=\left[\begin{array}{lll}0 &amp; 0 &amp; 0 \\ 0 &amp; -0.375 &amp; 0 \\ 0 &amp; 0 &amp; 1.5\end{array}\right]\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(C_{ij} = \left[\begin{array}{lll}1 &amp; 0 &amp; 0 \\ 0 &amp; 0.25 &amp; 0 \\ 0 &amp; 0 &amp; 4\end{array}\right]\)</span></p></td>
</tr>
<tr class="row-even"><td><p>Deformed</p></td>
<td><p><span class="math notranslate nohighlight">\(\bar{E}_{ij}=\left[\begin{array}{lll}0 &amp; 0 &amp; 0 \\ 0 &amp; -1.5 &amp; 0 \\ 0 &amp; 0 &amp; 0.375\end{array}\right]\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\bar{C}_{ij} = \left[\begin{array}{lll}1 &amp; 0 &amp; 0 \\ 0 &amp; 4 &amp; 0 \\ 0 &amp; 0 &amp; 0.25\end{array}\right]\)</span></p></td>
</tr>
</tbody>
</table>
<p>You can see that the diagonal components of the Green deformation tensor, <span class="math notranslate nohighlight">\(C_{ij}\)</span>, are the quadratic elongations, <span class="math notranslate nohighlight">\(\lambda_i\)</span>, along the coordinate axes, and the diagonal components of the Cauchy deformation tensor, <span class="math notranslate nohighlight">\(\bar{C}_{ij}\)</span>, are the inverse of the quadratic elongations, <span class="math notranslate nohighlight">\(1/\lambda_i\)</span>. The diagonal components of the Lagrangian and Eulerian finite strain tensors, <span class="math notranslate nohighlight">\(E_{ij}\)</span> and <span class="math notranslate nohighlight">\(\bar{E}_{ij}\)</span>, can be found from Eqs. <a class="reference internal" href="#equation-ch08-eq38">(8.38)</a> and <a class="reference internal" href="#equation-ch08-eq39">(8.39)</a>.</p>
<p>The function <a class="reference external" href="https://github.com/nfcd/compGeo/blob/master/source/functions/fin_strain.py">fin_strain</a> computes the finite strain from the displacement gradient tensor, in the undeformed (<code class="docutils literal notranslate"><span class="pre">frame</span></code> = 0) or deformed (<code class="docutils literal notranslate"><span class="pre">frame</span></code> = 1) configuration. Notice that for computing the maximum shear strain, the function assumes plane strain (Ramsay, 1967).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">compgeo.cart_to_sph</span> <span class="kn">import</span> <span class="n">cart_to_sph</span>


<span class="k">def</span> <span class="nf">fin_strain</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">frame</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    fin_strain computes finite strain from an input</span>
<span class="sd">    displacement gradient tensor</span>

<span class="sd">    USE: eps,pstrain,dilat,maxsh = fin_strain(e,frame)</span>

<span class="sd">    e = 3 x 3 Lagrangian or Eulerian displacement gradient</span>
<span class="sd">        tensor</span>
<span class="sd">    frame = Reference frame. 0 = undeformed (Lagrangian)</span>
<span class="sd">        state, 1 = deformed (Eulerian) state</span>
<span class="sd">    eps = 3 x 3 Lagrangian or Eulerian strain tensor</span>
<span class="sd">    pstrain = 3 x 3 matrix with magnitude (column 1), trend</span>
<span class="sd">        (column 2) and plunge (column 3) of maximum</span>
<span class="sd">        (row 1), intermediate (row 2), and minimum</span>
<span class="sd">        (row 3) elongations</span>
<span class="sd">    dilat = dilatation</span>
<span class="sd">    maxsh = 1 x 2 vector with max. shear strain and</span>
<span class="sd">        orientation with respect to maximum principal</span>
<span class="sd">        strain direction. Only valid in 2D</span>

<span class="sd">    NOTE: Output angles are in radians</span>

<span class="sd">    Python function translated from the Matlab function</span>
<span class="sd">    FinStrain in Allmendinger et al. (2012)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialize variables</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">pstrain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">maxsh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Compute strain tensor</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">e</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                
                <span class="c1"># If undeformed reference frame: </span>
                <span class="c1"># Lagrangian strain tensor</span>
                <span class="k">if</span> <span class="n">frame</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">e</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
                
                <span class="c1"># If deformed reference frame: </span>
                <span class="c1"># Eulerian strain tensor</span>
                <span class="k">elif</span> <span class="n">frame</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">e</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>

    <span class="c1"># Compute principal elongations and orientations</span>
    <span class="n">D</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">eps</span><span class="p">)</span>

    <span class="c1"># Principal elongations</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="mi">2</span><span class="o">-</span><span class="n">i</span>
        
        <span class="c1"># Magnitude</span>
        <span class="c1"># If undeformed reference frame: </span>
        <span class="c1"># Lagrangian strain tensor</span>
        <span class="k">if</span> <span class="n">frame</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pstrain</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="mf">2.0</span><span class="o">*</span><span class="n">D</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span><span class="o">-</span><span class="mf">1.0</span>
        
        <span class="c1"># If deformed reference frame:</span>
        <span class="c1"># Eulerian strain tensor</span>
        <span class="k">elif</span> <span class="n">frame</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">pstrain</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="mf">2.0</span><span class="o">*</span><span class="n">D</span><span class="p">[</span><span class="n">ind</span><span class="p">]))</span><span class="o">-</span><span class="mf">1.0</span>
        
        <span class="c1"># Orientations</span>
        <span class="n">pstrain</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">pstrain</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cart_to_sph</span><span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">ind</span><span class="p">],</span>
            <span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">ind</span><span class="p">],</span><span class="n">V</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="n">ind</span><span class="p">])</span>

    <span class="c1"># Dilatation</span>
    <span class="n">dilat</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="n">pstrain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="n">pstrain</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span> \
        <span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="n">pstrain</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mf">1.0</span>

    <span class="c1"># Maximum shear strain: This only works if plane strain</span>
    <span class="n">lmax</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="n">pstrain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="c1"># Maximum quad. elongation</span>
    <span class="n">lmin</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="n">pstrain</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="c1"># Minimum quad. elongation</span>
    
    <span class="c1"># Maximum shear strain: Ramsay (1967) Eq. 3.46</span>
    <span class="n">maxsh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">lmax</span><span class="o">-</span><span class="n">lmin</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lmax</span><span class="o">*</span><span class="n">lmin</span><span class="p">))</span>
    
    <span class="c1"># Angle of maximum shear strain with respect to maximum</span>
    <span class="c1"># principal strain. Ramsay (1967) Eq. 3.45</span>
    <span class="c1"># If undeformed reference frame</span>
    <span class="k">if</span> <span class="n">frame</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">maxsh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">4.0</span>
    
    <span class="c1"># If deformed reference frame</span>
    <span class="k">elif</span> <span class="n">frame</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">maxsh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lmin</span><span class="o">/</span><span class="n">lmax</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">eps</span><span class="p">,</span> <span class="n">pstrain</span><span class="p">,</span> <span class="n">dilat</span><span class="p">,</span> <span class="n">maxsh</span>
</pre></div>
</div>
</div>
</div>
<section id="mohr-circle-for-finite-strain">
<span id="ch08-4-1"></span><h3><span class="section-number">8.4.1. </span>Mohr circle for finite strain<a class="headerlink" href="#mohr-circle-for-finite-strain" title="Permalink to this headline">#</a></h3>
<p>The finite strain and deformation tensors are symmetric tensors. Therefore, a rotation about one of the principal axis of the tensor can be represented by a Mohr circle. As you may suspect, there are Mohr circles for finite strain in the undeformed and deformed configuration (Ramsay, 1967). For geoscientists, the Mohr circle for finite strain in the deformed configuration is the most important, since in nature we do observe deformed rocks.</p>
<p>To derive this Mohr circle, we can start with the Cauchy deformation tensor in a principal axes coordinate system:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq40">
<span class="eqno">(8.40)<a class="headerlink" href="#equation-ch08-eq40" title="Permalink to this equation">#</a></span>\[\begin{split}
\bar{C}_{i j}=\left[\begin{array}{ccc}\bar{C}_{1} &amp; 0 &amp; 0 \\ 0 &amp; \bar{C}_{2} &amp; 0 \\ 0 &amp; 0 &amp; \bar{C}_{3}\end{array}\right]
\end{split}\]</div>
<p>and perform a rotation <span class="math notranslate nohighlight">\(\theta\)</span> about <span class="math notranslate nohighlight">\(\mathbf{X_2}\)</span>, which is described by the transformation matrix:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq41">
<span class="eqno">(8.41)<a class="headerlink" href="#equation-ch08-eq41" title="Permalink to this equation">#</a></span>\[\begin{split}
a_{ij} = \begin{pmatrix}\cos\theta&amp;0&amp;\sin\theta\\0&amp;1&amp;0\\-\sin\theta&amp;0&amp;\cos\theta\end{pmatrix}
\end{split}\]</div>
<p>The tensor transformation equation is:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq42">
<span class="eqno">(8.42)<a class="headerlink" href="#equation-ch08-eq42" title="Permalink to this equation">#</a></span>\[
\bar{C}_{ij}' = a_{ik}a_{jl}\bar{C}_{kl}
\]</div>
<p>which results in the new form of the tensor:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq43">
<span class="eqno">(8.43)<a class="headerlink" href="#equation-ch08-eq43" title="Permalink to this equation">#</a></span>\[\begin{split}
\bar{C}'_{ij}=\begin{bmatrix}\bar{C}_1\cos^2\theta+\bar{C}_3\sin^2\theta&amp;0&amp;-(\bar{C}_1-\bar{C}_3)\sin\theta\cos\theta\\0&amp;\bar{C}_2&amp;0\\-(\bar{C}_1-\bar{C}_3)\sin\theta\cos\theta&amp;0&amp;\bar{C}_1\sin^2\theta+\bar{C}_3\cos^2\theta\end{bmatrix}
\end{split}\]</div>
<p>Upon rearranging, we get:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq44">
<span class="eqno">(8.44)<a class="headerlink" href="#equation-ch08-eq44" title="Permalink to this equation">#</a></span>\[\begin{split}
\begin{gathered}
    \bar{C}_{11}'=\frac{\bar{C}_1+\bar{C}_3}{2}+\frac{\bar{C}_1-\bar{C}_3}{2}\cos 2\theta  \\
    \bar{C}_{33}'=\frac{\bar{C}_1+\bar{C}_3}{2}-\frac{\bar{C}_1-\bar{C}_3}{2}\cos 2\theta \\
    \bar{C}_{13}'=\bar{C}_{31}'=-\frac{\bar{C}_1-\bar{C}_3}{2}\sin 2\theta
\end{gathered}
\end{split}\]</div>
<p>As stated in Eq. <a class="reference internal" href="#equation-ch08-eq39">(8.39)</a>, <span class="math notranslate nohighlight">\(\bar{C}_{ii} = 1/\lambda_i\)</span>. Also <span class="math notranslate nohighlight">\(\bar{C}_{ij}\)</span> for <span class="math notranslate nohighlight">\(i \neq j\)</span> is equal to <span class="math notranslate nohighlight">\(\gamma / \lambda\)</span>. Using <span class="math notranslate nohighlight">\(\lambda ' = 1/\lambda\)</span> and <span class="math notranslate nohighlight">\(\gamma ' = \gamma / \lambda\)</span>, we get the equations for the Mohr circle for finite strain in the deformed configuration:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq45">
<span class="eqno">(8.45)<a class="headerlink" href="#equation-ch08-eq45" title="Permalink to this equation">#</a></span>\[\begin{split}
\begin{gathered}
    \lambda^{\prime}=\frac{\left(\lambda_{1}^{\prime}+\lambda_{3}^{\prime}\right)}{2}+\frac{\left(\lambda_{1}^{\prime}-\lambda_{3}^{\prime}\right)}{2} \cos 2 \theta  \\
    \gamma^{\prime}=-\frac{\left(\lambda_{1}^{\prime}-\lambda_{3}^{\prime}\right)}{2} \sin 2 \theta
\end{gathered}
\end{split}\]</div>
<p>As an example, <a class="reference internal" href="#ch08-fig07"><span class="std std-numref">Figure 8.7</span></a>a shows a deformed circle and an inscribed triangle after 30<span class="math notranslate nohighlight">\(^o\)</span> clockwise shear. <a class="reference internal" href="#ch08-fig07"><span class="std std-numref">Figure 8.7</span></a>b shows the Mohr circle for this deformation. In the Mohr circle, the horizontal axis is <span class="math notranslate nohighlight">\(\lambda'\)</span>, and the vertical axis is <span class="math notranslate nohighlight">\(\gamma'\)</span>. We follow the convention of Ragan (2009): Positive angular shear, <span class="math notranslate nohighlight">\(\psi\)</span>, corresponds to anticlockwise rotation of the original line’s normal (<a class="reference internal" href="#ch08-fig07"><span class="std std-numref">Figure 8.7</span></a>a), and the <span class="math notranslate nohighlight">\(\gamma'\)</span> axis in the Mohr circle increases downwards (<a class="reference internal" href="#ch08-fig07"><span class="std std-numref">Figure 8.7</span></a>b). Notice that the angle between the horizontal axis and a line from the origin to any point in the Mohr circle is equal to <span class="math notranslate nohighlight">\(\psi\)</span>. Therefore, a line from the origin and tangent to the Mohr circle indicates <span class="math notranslate nohighlight">\(\psi_{\text{max}}\)</span> (<a class="reference internal" href="#ch08-fig07"><span class="std std-numref">Figure 8.7</span></a>b).</p>
<figure class="align-default" id="ch08-fig07">
<a class="reference internal image-reference" href="_images/ch08_fig07.png"><img alt="_images/ch08_fig07.png" src="_images/ch08_fig07.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 8.7 </span><span class="caption-text"><strong>a.</strong> Physical plane, and <strong>b.</strong> Mohr circle for 30° clockwise shear of a circle and a triangle. The pole, the triangle bisectors a, b and c (red and blue), the principal strain axes <span class="math notranslate nohighlight">\(S_{1}\)</span> and <span class="math notranslate nohighlight">\(S_{3}\)</span> (black), the LNFE (green), and the lines of maximum shear strain (orange) are all drawn in the Mohr circle.</span><a class="headerlink" href="#ch08-fig07" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>From points in the Mohr circle, one can trace the corresponding lines with the same orientation than in the physical plane (<a class="reference internal" href="#ch08-fig07"><span class="std std-numref">Figure 8.7</span></a>b, triangle bisectors a, b and c). These lines will intersect at a point called the <em>pole</em> to the Mohr circle (<a class="reference internal" href="#ch08-fig07"><span class="std std-numref">Figure 8.7</span></a>b). From the pole, one can trace lines of any orientation; they will intersect the circle at points that represent the strain of lines with the same orientation in the physical plane. Thus, you can imagine the pole to be the center of the strain ellipse, and from it, it is easy to trace the principal axes of strain (<span class="math notranslate nohighlight">\(S_1\)</span> and <span class="math notranslate nohighlight">\(S_3\)</span>), the lines of no finite elongation (LNFE, <span class="math notranslate nohighlight">\(\lambda'=1\)</span>), and the lines of maximum shear strain (<a class="reference internal" href="#ch08-fig07"><span class="std std-numref">Figure 8.7</span></a>b).</p>
</section>
<section id="d-finite-strain-from-displacement-data">
<span id="ch08-4-2"></span><h3><span class="section-number">8.4.2. </span>2D finite strain from displacement data<a class="headerlink" href="#d-finite-strain-from-displacement-data" title="Permalink to this headline">#</a></h3>
<p>If we have a group of points or stations with displacement data, we can determine the finite strain following a strategy similar to the one we used for infinitesimal strain. The function <a class="reference external" href="https://github.com/nfcd/compGeo/blob/master/source/functions/grid_fin_strain.py">grid_fin_strain</a> computes and plots the finite strain for a group of points with displacement data. This function is very similar to our previous function <code class="docutils literal notranslate"><span class="pre">grid_strain</span></code>, and therefore we only include its header here. Notice that after computing the displacement gradient in the undeformed (<code class="docutils literal notranslate"><span class="pre">frame</span></code> = 0) or deformed (<code class="docutils literal notranslate"><span class="pre">frame</span></code> = 1) configuration, we use our function <code class="docutils literal notranslate"><span class="pre">fin_strain</span></code> to compute the finite strain in each cell.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib.colors</span> <span class="k">as</span> <span class="nn">mcolors</span>
<span class="kn">from</span> <span class="nn">matplotlib.patches</span> <span class="kn">import</span> <span class="n">Polygon</span>
<span class="kn">from</span> <span class="nn">matplotlib.collections</span> <span class="kn">import</span> <span class="n">PatchCollection</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">Delaunay</span>

<span class="kn">from</span> <span class="nn">compgeo.lscov</span> <span class="kn">import</span> <span class="n">lscov</span>
<span class="kn">from</span> <span class="nn">compgeo.fin_strain</span> <span class="kn">import</span> <span class="n">fin_strain</span>


<span class="k">def</span> <span class="nf">grid_fin_strain</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="n">disp</span><span class="p">,</span><span class="n">frame</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">par</span><span class="p">,</span><span class="n">plotpar</span><span class="p">,</span><span class="n">plotst</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    grid_fin_strain computes the finite strain of a group</span>
<span class="sd">    of points with displacements in x and y.</span>
<span class="sd">    Strain in z is assumed to be zero (plane strain)</span>
<span class="sd">    </span>
<span class="sd">    USE: cent,eps,pstrain,dilat,maxsh,fig,ax = </span>
<span class="sd">        grid_fin_strain(pos,disp,frame,k,par,plotpar,plotst)</span>
<span class="sd">    </span>
<span class="sd">    pos = npoints x 2 matrix with x and y position</span>
<span class="sd">        of points</span>
<span class="sd">    disp = nstations x 2 matrix with x and y</span>
<span class="sd">        displacements of points</span>
<span class="sd">    frame = Reference frame. 0 = undeformed (Lagrangian)</span>
<span class="sd">        state, 1 = deformed (Eulerian) state</span>
<span class="sd">    k = Type of computation: Delaunay (k = 0), nearest</span>
<span class="sd">        neighbor (k = 1), or distance weighted (k = 2)</span>
<span class="sd">    par = Parameters for nearest neighbor or distance</span>
<span class="sd">        weighted computation. If Delaunay (k = 0), enter</span>
<span class="sd">        a scalar corresponding to the minimum internal</span>
<span class="sd">        angle of a triangle valid for computation.</span>
<span class="sd">        If nearest neighbor (k = 1), input a 1 x 3 vector</span>
<span class="sd">        with grid spacing, number of nearest neighbors,</span>
<span class="sd">        and maximum distance to neighbors. If distance</span>
<span class="sd">        weighted (k = 2), input a 1 x 2 vector with grid</span>
<span class="sd">        spacing and distance weighting factor alpha</span>
<span class="sd">    plotpar = Parameter to color the cells: Max elongation</span>
<span class="sd">        (plotpar = 0), minimum elongation</span>
<span class="sd">        (plotpar = 1), dilatation (plotpar = 2),</span>
<span class="sd">        or max. shear strain (plotpar = 3)</span>
<span class="sd">    plotst = A flag to plot the stations (1) or not (0)</span>
<span class="sd">    cent = ncells x 2 matrix with x and y positions of the</span>
<span class="sd">        cells centroids</span>
<span class="sd">    eps = 3 x 3 x ncells array    with strain tensors of</span>
<span class="sd">        the cells</span>
<span class="sd">    pstrain = 3 x 3 x ncells array with magnitude and</span>
<span class="sd">        orientation of principal strains of the cells</span>
<span class="sd">    dilat = ncells x 1 vector with dilatation of the cells</span>
<span class="sd">    maxsh = ncells x 2 matrix with max. shear strain and</span>
<span class="sd">        orientation with respect to maximum principal</span>
<span class="sd">        strain direction, of the cells.</span>
<span class="sd">        Only valid for plane strain</span>
<span class="sd">        </span>
<span class="sd">    fig and ax are handles to the figure and axes</span>
<span class="sd">    </span>
<span class="sd">    NOTE: Input/Output angles are in radians. Output</span>
<span class="sd">        azimuths are given with respect to y</span>
<span class="sd">        pos, disp, grid spacing, max. distance to</span>
<span class="sd">        neighbors, and alpha should be in the same</span>
<span class="sd">        length units</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If Delaunay</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Indexes of triangles vertices</span>
        <span class="c1"># Use function Delaunay</span>
        <span class="n">tri</span> <span class="o">=</span> <span class="n">Delaunay</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="n">tri</span><span class="o">.</span><span class="n">simplices</span>
        <span class="c1"># Number of cells</span>
        <span class="n">ncells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Number of stations per cell = 3</span>
        <span class="n">nstat</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="c1"># Centers of cells</span>
        <span class="n">cent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ncells</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncells</span><span class="p">):</span>
            <span class="c1"># Triangle vertices</span>
            <span class="n">v1x</span><span class="o">=</span><span class="n">pos</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">v2x</span><span class="o">=</span><span class="n">pos</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">v3x</span><span class="o">=</span><span class="n">pos</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">v1y</span><span class="o">=</span><span class="n">pos</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">v2y</span><span class="o">=</span><span class="n">pos</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">v3y</span><span class="o">=</span><span class="n">pos</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Center of cell</span>
            <span class="n">cent</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">v1x</span> <span class="o">+</span> <span class="n">v2x</span> <span class="o">+</span> <span class="n">v3x</span><span class="p">)</span><span class="o">/</span><span class="mf">3.0</span>
            <span class="n">cent</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">v1y</span> <span class="o">+</span> <span class="n">v2y</span> <span class="o">+</span> <span class="n">v3y</span><span class="p">)</span><span class="o">/</span><span class="mf">3.0</span>
            <span class="c1"># Triangle internal angles</span>
            <span class="n">s1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">v3x</span><span class="o">-</span><span class="n">v2x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">v3y</span><span class="o">-</span><span class="n">v2y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">s2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">v1x</span><span class="o">-</span><span class="n">v3x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">v1y</span><span class="o">-</span><span class="n">v3y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">s3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">v2x</span><span class="o">-</span><span class="n">v1x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">v2y</span><span class="o">-</span><span class="n">v1y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">a1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">((</span><span class="n">v2x</span><span class="o">-</span><span class="n">v1x</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">v3x</span><span class="o">-</span><span class="n">v1x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">s3</span><span class="o">*</span><span class="n">s2</span><span class="p">)</span><span class="o">+</span>\
                <span class="p">(</span><span class="n">v2y</span><span class="o">-</span><span class="n">v1y</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">v3y</span><span class="o">-</span><span class="n">v1y</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">s3</span><span class="o">*</span><span class="n">s2</span><span class="p">))</span>
            <span class="n">a2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">((</span><span class="n">v3x</span><span class="o">-</span><span class="n">v2x</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">v1x</span><span class="o">-</span><span class="n">v2x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">s1</span><span class="o">*</span><span class="n">s3</span><span class="p">)</span><span class="o">+</span>\
                <span class="p">(</span><span class="n">v3y</span><span class="o">-</span><span class="n">v2y</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">v1y</span><span class="o">-</span><span class="n">v2y</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">s1</span><span class="o">*</span><span class="n">s3</span><span class="p">))</span>
            <span class="n">a3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">((</span><span class="n">v2x</span><span class="o">-</span><span class="n">v3x</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">v1x</span><span class="o">-</span><span class="n">v3x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">s1</span><span class="o">*</span><span class="n">s2</span><span class="p">)</span><span class="o">+</span>\
                <span class="p">(</span><span class="n">v2y</span><span class="o">-</span><span class="n">v3y</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">v1y</span><span class="o">-</span><span class="n">v3y</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">s1</span><span class="o">*</span><span class="n">s2</span><span class="p">))</span>
            <span class="c1"># If any of the internal angles is less than</span>
            <span class="c1"># specified minimum, invalidate triangle</span>
            <span class="k">if</span> <span class="n">a1</span> <span class="o">&lt;</span> <span class="n">par</span> <span class="ow">or</span> <span class="n">a2</span> <span class="o">&lt;</span> <span class="n">par</span> <span class="ow">or</span> <span class="n">a3</span> <span class="o">&lt;</span> <span class="n">par</span><span class="p">:</span>
                <span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="c1"># If nearest neighbor or distance weighted</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Construct grid</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">pos</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]);</span> <span class="n">xmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">pos</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">pos</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]);</span> <span class="n">ymax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">pos</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">cellsx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">xmax</span><span class="o">-</span><span class="n">xmin</span><span class="p">)</span><span class="o">/</span><span class="n">par</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">cellsy</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">ymax</span><span class="o">-</span><span class="n">ymin</span><span class="p">)</span><span class="o">/</span><span class="n">par</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">xgrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">xmin</span><span class="p">,(</span><span class="n">xmin</span><span class="o">+</span><span class="p">(</span><span class="n">cellsx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">par</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">par</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ygrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ymin</span><span class="p">,(</span><span class="n">ymin</span><span class="o">+</span><span class="p">(</span><span class="n">cellsy</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">par</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">par</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">XX</span><span class="p">,</span><span class="n">YY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xgrid</span><span class="p">,</span><span class="n">ygrid</span><span class="p">)</span>
        <span class="c1"># Number of cells</span>
        <span class="n">ncells</span> <span class="o">=</span> <span class="n">cellsx</span> <span class="o">*</span> <span class="n">cellsy</span>
        <span class="c1"># Number of stations per cell (nstat) and</span>
        <span class="c1"># other parameters</span>
        <span class="c1"># If nearest neighbor</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">nstat</span> <span class="o">=</span> <span class="n">par</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># max neighbors</span>
            <span class="n">sqmd</span> <span class="o">=</span> <span class="n">par</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="c1"># max squared distance</span>
        <span class="c1"># If distance weighted</span>
        <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">nstat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># all stations</span>
            <span class="n">dalpha</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">par</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">par</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># 2*alpha*alpha</span>
        <span class="c1"># Cells&quot; centers</span>
        <span class="n">cent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ncells</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cellsy</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cellsx</span><span class="p">):</span>
                <span class="n">cent</span><span class="p">[</span><span class="n">count</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">XX</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">XX</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mf">2.0</span>
                <span class="n">cent</span><span class="p">[</span><span class="n">count</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">YY</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">YY</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">])</span><span class="o">/</span><span class="mf">2.0</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Initialize stations indexes for cells to -1</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">ncells</span><span class="p">,</span><span class="n">nstat</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">*-</span><span class="mi">1</span>
        <span class="c1"># Initialize weight matrix for distance weighted</span>
        <span class="n">wv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ncells</span><span class="p">,</span><span class="n">nstat</span><span class="o">*</span><span class="mi">2</span><span class="p">))</span>
        <span class="c1"># For all cells set stations indexes</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncells</span><span class="p">):</span>
            <span class="c1"># Initialize sq distances to -1.0</span>
            <span class="n">sds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nstat</span><span class="p">)</span><span class="o">*-</span><span class="mf">1.0</span>
            <span class="c1"># For all stations</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
                <span class="c1"># Sq distance from cell center to station</span>
                <span class="n">dx</span> <span class="o">=</span> <span class="n">cent</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">dy</span> <span class="o">=</span> <span class="n">cent</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">sd</span> <span class="o">=</span> <span class="n">dx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">dy</span><span class="o">**</span><span class="mi">2</span>
                <span class="c1"># If nearest neighbor</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># If within the max sq distance</span>
                    <span class="k">if</span> <span class="n">sd</span> <span class="o">&lt;=</span> <span class="n">sqmd</span><span class="p">:</span>
                        <span class="n">minsd</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">sds</span><span class="p">)</span>
                        <span class="n">mini</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">sds</span><span class="p">)</span>
                        <span class="c1"># If less than max neighbors</span>
                        <span class="k">if</span> <span class="n">minsd</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>
                            <span class="n">sds</span><span class="p">[</span><span class="n">mini</span><span class="p">]</span> <span class="o">=</span> <span class="n">sd</span>
                            <span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">mini</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
                        <span class="c1"># If max neighbors</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># If sq distance is less</span>
                            <span class="c1"># than neighbors max sq distance</span>
                            <span class="n">maxsd</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">sds</span><span class="p">)</span>
                            <span class="n">maxi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">sds</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">sd</span> <span class="o">&lt;</span> <span class="n">maxsd</span><span class="p">:</span>
                                <span class="n">sds</span><span class="p">[</span><span class="n">maxi</span><span class="p">]</span> <span class="o">=</span> <span class="n">sd</span>
                                <span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">maxi</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
                <span class="c1"># If distance weighted</span>
                <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="c1"># All stations indexes</span>
                    <span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nstat</span><span class="p">)</span>
                    <span class="c1"># Eq. 8.27: Weight factor</span>
                    <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">sd</span><span class="o">/</span><span class="n">dalpha</span><span class="p">)</span>
                    <span class="n">wv</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span>
                    <span class="n">wv</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span>
    
    <span class="c1"># Initialize arrays</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nstat</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nstat</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span> 
    <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">ncells</span><span class="p">))</span> 
    <span class="n">pstrain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">ncells</span><span class="p">))</span>
    <span class="n">dilat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ncells</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">maxsh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ncells</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> 
        
    <span class="c1"># For each cell</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncells</span><span class="p">):</span>
        <span class="c1"># If required minimum number of stations</span>
        <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Eq. 8.24: Displacements column vector y</span>
            <span class="c1"># and design matrix M. X1 = y, X2 = x</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nstat</span><span class="p">):</span>
                <span class="n">ic</span> <span class="o">=</span> <span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
                <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">disp</span><span class="p">[</span><span class="n">ic</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">disp</span><span class="p">[</span><span class="n">ic</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="n">pos</span><span class="p">[</span><span class="n">ic</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">pos</span><span class="p">[</span><span class="n">ic</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]</span>
                <span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="n">pos</span><span class="p">[</span><span class="n">ic</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">pos</span><span class="p">[</span><span class="n">ic</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>
            <span class="c1"># Eqs. 8.25-8.26: Find x using function lscov</span>
            <span class="c1"># If Delaunay or nearest neighbor</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">lscov</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
            <span class="c1"># If distance weighted</span>
            <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">lscov</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">wv</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span>
            <span class="c1"># Displacement gradient tensor</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">e</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">e</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span>
            <span class="c1"># Compute strain</span>
            <span class="n">eps</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">],</span><span class="n">pstrain</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">],</span><span class="n">dilat</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span>\
                <span class="n">maxsh</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">fin_strain</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">frame</span><span class="p">)</span>

    <span class="c1"># Variable to plot</span>
    <span class="c1"># If maximum principal strain</span>
    <span class="k">if</span> <span class="n">plotpar</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">vp</span> <span class="o">=</span> <span class="n">pstrain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="mf">2.0</span>
        <span class="n">lcb</span> <span class="o">=</span> <span class="s2">&quot;emax&quot;</span>
    <span class="c1"># If minimum principal strain</span>
    <span class="k">elif</span> <span class="n">plotpar</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">vp</span> <span class="o">=</span> <span class="n">pstrain</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.0</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">lcb</span> <span class="o">=</span> <span class="s2">&quot;emin&quot;</span>
    <span class="c1"># If dilatation:</span>
    <span class="k">elif</span> <span class="n">plotpar</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">vp</span> <span class="o">=</span> <span class="n">dilat</span><span class="p">[:]</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">lcb</span> <span class="o">=</span> <span class="s2">&quot;dilatation&quot;</span>
    <span class="c1"># If max. shear strain</span>
    <span class="k">elif</span> <span class="n">plotpar</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">vp</span> <span class="o">=</span> <span class="n">maxsh</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="mf">2.0</span>
        <span class="n">lcb</span> <span class="o">=</span> <span class="s2">&quot;max. shear strain&quot;</span>

    <span class="c1"># Make a figure</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">15.0</span><span class="p">,</span><span class="mf">7.5</span><span class="p">))</span>
    
    <span class="c1"># Patches and colors for cells</span>
    <span class="n">patches</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># Fill cells patches and colors</span>
    <span class="c1"># If Delaunay</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncells</span><span class="p">):</span>
            <span class="c1"># If minimum number of stations</span>
                <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">xpyp</span> <span class="o">=</span> <span class="p">[[</span><span class="n">pos</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">],</span><span class="n">pos</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">]],</span>\
                            <span class="p">[</span><span class="n">pos</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="mi">0</span><span class="p">],</span><span class="n">pos</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">]],</span>\
                            <span class="p">[</span><span class="n">pos</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="mi">0</span><span class="p">],</span><span class="n">pos</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="mi">1</span><span class="p">]]]</span>
                    <span class="n">polygon</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">xpyp</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                    <span class="n">patches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span>
                    <span class="n">colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="c1"># If nearest neighbor or distance weighted</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cellsy</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cellsx</span><span class="p">):</span>
                <span class="c1"># If minimum number of stations</span>
                <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">inds</span><span class="p">[</span><span class="n">count</span><span class="p">,:])</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">xpyp</span> <span class="o">=</span> <span class="p">[[</span><span class="n">XX</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span><span class="n">YY</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]],[</span><span class="n">XX</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">YY</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span>\
                        <span class="p">[</span><span class="n">XX</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">YY</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]],[</span><span class="n">XX</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">],</span><span class="n">YY</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]]]</span>
                    <span class="n">polygon</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">xpyp</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                    <span class="n">patches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span>
                    <span class="n">colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vp</span><span class="p">[</span><span class="n">count</span><span class="p">])</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Collect cells patches</span>
    <span class="n">pcoll</span> <span class="o">=</span> <span class="n">PatchCollection</span><span class="p">(</span><span class="n">patches</span><span class="p">)</span>
    <span class="c1"># Cells colors</span>
    <span class="n">pcoll</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">colors</span><span class="p">))</span>
    <span class="c1"># Color map is blue to red</span>
    <span class="n">pcoll</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="s2">&quot;jet&quot;</span><span class="p">)</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span><span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
    <span class="n">pcoll</span><span class="o">.</span><span class="n">set_norm</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
    
    <span class="c1"># Draw cells</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">pcoll</span><span class="p">)</span>
    
    <span class="c1"># Plot stations</span>
    <span class="k">if</span> <span class="n">plotst</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pos</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">pos</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="s2">&quot;k.&quot;</span><span class="p">,</span><span class="n">markersize</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> 
    
    <span class="c1"># Axes</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;equal&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
    
    <span class="c1"># Color bar with nice ticks</span>
    <span class="n">intv</span> <span class="o">=</span> <span class="p">(</span><span class="n">vmax</span><span class="o">-</span><span class="n">vmin</span><span class="p">)</span><span class="o">*</span><span class="mf">0.25</span>
    <span class="n">ticks</span><span class="o">=</span><span class="p">[</span><span class="n">vmin</span><span class="p">,</span><span class="n">vmin</span><span class="o">+</span><span class="n">intv</span><span class="p">,</span><span class="n">vmin</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">intv</span><span class="p">,</span><span class="n">vmin</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">intv</span><span class="p">,</span><span class="n">vmax</span><span class="p">]</span>
    <span class="n">lticks</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">{:.2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ticks</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>\
            <span class="s2">&quot;</span><span class="si">{:.2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ticks</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="s2">&quot;</span><span class="si">{:.2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ticks</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>\
            <span class="s2">&quot;</span><span class="si">{:.2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ticks</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span><span class="s2">&quot;</span><span class="si">{:.2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ticks</span><span class="p">[</span><span class="mi">4</span><span class="p">])]</span>
    <span class="n">cbar</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">pcoll</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">lcb</span><span class="p">,</span> <span class="n">ticks</span><span class="o">=</span><span class="n">ticks</span><span class="p">)</span>
    <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="n">lticks</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">cent</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">pstrain</span><span class="p">,</span> <span class="n">dilat</span><span class="p">,</span> <span class="n">maxsh</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s use this function to compute the maximum shear strain of a discrete element model of a normal fault. The discrete element method is a mechanical method that simulates the rocks as an assembly of elements. The file <a class="reference external" href="https://github.com/nfcd/compGeo/blob/master/source/data/ch8-3/demfault.txt">demfault.txt</a> contains the deformed <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> coordinates of the elements and their displacements in meters. The notebook <a class="reference external" href="https://github.com/nfcd/compGeo/blob/master/source/notebooks/ch8-3.ipynb">ch8-3</a> shows the solution to this problem using the nearest neighbor method:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Import function grid_fin_strain</span>
<span class="kn">from</span> <span class="nn">compgeo.grid_fin_strain</span> <span class="kn">import</span> <span class="n">grid_fin_strain</span>

<span class="c1"># load x, y deformed coordinates and displacements</span>
<span class="n">demfault</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="s2">&quot;data/ch8-3/demfault.txt&quot;</span><span class="p">))</span>
<span class="n">pos</span> <span class="o">=</span> <span class="n">demfault</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="n">disp</span> <span class="o">=</span> <span class="n">demfault</span><span class="p">[:,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>

<span class="c1"># Max. shear strain from nearest neighbor, Def. config. </span>
<span class="c1"># Grid spacing = 0.2 m, neighbors 6, </span>
<span class="c1"># max. distance = 0.4 m, plot stations</span>
<span class="n">par</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mf">0.4</span><span class="p">]</span>
<span class="n">cent</span><span class="p">,</span><span class="n">eps</span><span class="p">,</span><span class="n">pstrain</span><span class="p">,</span><span class="n">dilat</span><span class="p">,</span><span class="n">maxsh</span><span class="p">,</span><span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">grid_fin_strain</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span>
                                        <span class="n">disp</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">par</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Add units to the axes</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;x [m]&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;y [m]&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ch08_strain_130_0.png" src="_images/ch08_strain_130_0.png" />
</div>
</div>
<p>The maximum shear strain delineates the internal structure of the fault. You can find more information about computing strain from displacement or velocity data in Cardozo and Allmendinger (2009).</p>
</section>
</section>
<section id="progressive-strain">
<span id="ch08-5"></span><h2><span class="section-number">8.5. </span>Progressive strain<a class="headerlink" href="#progressive-strain" title="Permalink to this headline">#</a></h2>
<p>We have focused so far on the undeformed (initial) and deformed (final) states. However, finite strain is actually the cumulative result of a series of strain increments:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq46">
<span class="eqno">(8.46)<a class="headerlink" href="#equation-ch08-eq46" title="Permalink to this equation">#</a></span>\[\begin{split}
\begin{aligned}{ }^{1} x_{i} &amp;={ }^{1} F_{i j}{ }^{1} X_{j} \\{ }^{2} X_{i} &amp;={ }^{1} x_{i} \\{ }^{2} x_{i} &amp;={ }^{2} F_{i j}{ }^{2} X_{j} \\{ }^{3} X_{i} &amp;={ }^{2} x_{i} \\{ }^{3} x_{i} &amp;={ }^{3} F_{i j}{ }^{3} X_{j} \\ \cdots \\{ }^{n} x_{i} &amp;={ }^{n} F_{i j}{ }^{n} X_{j} \end{aligned}
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(F_{ij}\)</span> is the Green deformation gradient, and <span class="math notranslate nohighlight">\(1\)</span> to <span class="math notranslate nohighlight">\(n\)</span> are the strain increments. This can also be written as:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq47">
<span class="eqno">(8.47)<a class="headerlink" href="#equation-ch08-eq47" title="Permalink to this equation">#</a></span>\[
x_{i}={ }^{n} F_{i j} \ldots{ }^{3} F_{i j}{ }^{2} F_{i j}{ }^{1} F_{i j}{ }^{1} X_{j}
\]</div>
<p>Notice that since <span class="math notranslate nohighlight">\({ }^{2}\mathbf{F}{ }^{1}\mathbf{F}\neq{ }^{1}\mathbf{F}{ }^{2}\mathbf{F}\)</span>, for finite strain we must know the order of deformation. For example, if we want to determine the finite strain of a group of faults in a region, we must know the order at which these faults formed. This is often very difficult to determine.</p>
<p>Let’s look at some simple deformations, which are characterized by the same incremental deformation gradient through time. For simplicity, we will assume that there is no strain along the <span class="math notranslate nohighlight">\(\mathbf{X_2}\)</span> axis, and all strain is in the <span class="math notranslate nohighlight">\(\mathbf{X_1}\mathbf{X_3}\)</span> plane. Thus, we will be dealing with plane strain.</p>
<section id="pure-shear">
<span id="ch08-5-1"></span><h3><span class="section-number">8.5.1. </span>Pure shear<a class="headerlink" href="#pure-shear" title="Permalink to this headline">#</a></h3>
<p>For pure shear, the principal stretches are along the coordinate axes (e.g. <a class="reference internal" href="#ch08-fig02"><span class="std std-numref">Figure 8.2</span></a>). Let’s assume the maximum principal stretch, <span class="math notranslate nohighlight">\(S_1\)</span>, is along <span class="math notranslate nohighlight">\(\mathbf{X_1}\)</span>, and the minimum principal strecth, <span class="math notranslate nohighlight">\(S_3\)</span>, is along <span class="math notranslate nohighlight">\(\mathbf{X_3}\)</span> (<a class="reference internal" href="#ch08-fig08"><span class="std std-numref">Figure 8.8</span></a>a). <span class="math notranslate nohighlight">\(S_2 = 1\)</span> (plane strain) and is parallel to <span class="math notranslate nohighlight">\(\mathbf{X_2}\)</span>. The Green deformation gradient for this case is:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq48">
<span class="eqno">(8.48)<a class="headerlink" href="#equation-ch08-eq48" title="Permalink to this equation">#</a></span>\[\begin{split}
{ }^{PS}F_{ij}=\left[\begin{array}{ccc}S_{1} &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; S_{3}\end{array}\right]
\end{split}\]</div>
<figure class="align-default" id="ch08-fig08">
<a class="reference internal image-reference" href="_images/ch08_fig08.png"><img alt="_images/ch08_fig08.png" src="_images/ch08_fig08.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 8.8 </span><span class="caption-text"><strong>a.</strong> Pure shear, and <strong>b.</strong> Simple shear. Blue is undeformed, and red is deformed geometry. Large white and gray circles are initial and final positions, respectively. The displacement paths of the points are divided in 10 increments. Modified from Allmendinger et al. (2012).</span><a class="headerlink" href="#ch08-fig08" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>The function <a class="reference external" href="https://github.com/nfcd/compGeo/blob/master/source/functions/pure_shear.py">pure_shear</a> deforms a collection of points using pure shear, a value of <span class="math notranslate nohighlight">\(S_1\)</span> (<code class="docutils literal notranslate"><span class="pre">st1</span></code>), and assuming plane strain and area conservation (<span class="math notranslate nohighlight">\(S_1S_3 = 1\)</span>). The function displays the points’ displacement paths for a number of increments (<code class="docutils literal notranslate"><span class="pre">ninc</span></code>), and the progressive strain history as the value of <span class="math notranslate nohighlight">\(S_1\)</span> versus the angle <span class="math notranslate nohighlight">\(S_1\)</span> makes with the <span class="math notranslate nohighlight">\(\mathbf{X_1}\)</span> axis (<span class="math notranslate nohighlight">\(\Theta\)</span>). The last two parameters are computed from the eigenvalues and eigenvectors of the Green deformation tensor:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>


<span class="k">def</span> <span class="nf">pure_shear</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span><span class="n">st1</span><span class="p">,</span><span class="n">ninc</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    pure_shear computes and plots displacement paths and</span>
<span class="sd">    progressive finite strain history for pure shear with</span>
<span class="sd">    maximum stretching parallel to the X1 axis</span>

<span class="sd">    USE: paths,pfs,fig,ax = pure_shear(pts,st1,ninc)</span>

<span class="sd">    pts: npoints x 2 matrix with X1 and X3 coord. of points</span>
<span class="sd">    st1 = Maximum principal stretch</span>
<span class="sd">    ninc = number of strain increments</span>
<span class="sd">    paths = displacement paths of points</span>
<span class="sd">    pfs = progressive finite strain history. column 1 =</span>
<span class="sd">        orientation of maximum stretch with respect to X1</span>
<span class="sd">        in degrees, column 2 = maximum stretch magnitude</span>

<span class="sd">    fig and ax are handles to the figure and axes</span>

<span class="sd">    NOTE: Intermediate principal stretch is 1.0 (Plane </span>
<span class="sd">        strain). Output orientations are in radians</span>

<span class="sd">    Python function based on the Matlab function</span>
<span class="sd">    PureShear in Allmendinger et al. (2012)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Compute minimum principal stretch and incr. stretches</span>
    <span class="n">st1inc</span><span class="o">=</span><span class="n">st1</span><span class="o">**</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">ninc</span><span class="p">)</span>
    <span class="n">st3</span><span class="o">=</span><span class="mf">1.0</span><span class="o">/</span><span class="n">st1</span>
    <span class="n">st3inc</span><span class="o">=</span><span class="n">st3</span><span class="o">**</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">ninc</span><span class="p">)</span>

    <span class="c1"># Initialize displacement paths</span>
    <span class="n">npts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># Number of points</span>
    <span class="n">paths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ninc</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">npts</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">paths</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">pts</span> <span class="c1"># Initial points of paths</span>

    <span class="c1"># Calculate incr. deformation gradient tensor</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">st1inc</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">st3inc</span><span class="p">]])</span>

    <span class="c1"># Initialize figure</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span> <span class="c1"># 1 x 2 figure</span>

    <span class="c1"># Compute displacement paths</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npts</span><span class="p">):</span> <span class="c1"># for all points</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ninc</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># for all strain increments</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                    <span class="n">paths</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">F</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">L</span><span class="p">]</span><span class="o">*</span><span class="n">paths</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">L</span><span class="p">]</span> <span class="o">+</span> <span class="n">paths</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">]</span>
        
        <span class="c1"># Plot displacement path of point</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">paths</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">paths</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;k.-&quot;</span><span class="p">)</span>

    <span class="c1"># Plot initial polygon</span>
    <span class="n">inpol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npts</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">inpol</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">npts</span><span class="p">,]</span><span class="o">=</span><span class="n">paths</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">npts</span><span class="p">,:]</span>
    <span class="n">inpol</span><span class="p">[</span><span class="n">npts</span><span class="p">,]</span> <span class="o">=</span> <span class="n">inpol</span><span class="p">[</span><span class="mi">0</span><span class="p">,]</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">inpol</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">inpol</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="s2">&quot;b-&quot;</span><span class="p">)</span>
    
    <span class="c1"># Plot final polygon</span>
    <span class="n">finpol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npts</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">finpol</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">npts</span><span class="p">,]</span><span class="o">=</span><span class="n">paths</span><span class="p">[</span><span class="n">ninc</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">npts</span><span class="p">,:]</span>
    <span class="n">finpol</span><span class="p">[</span><span class="n">npts</span><span class="p">,]</span> <span class="o">=</span> <span class="n">finpol</span><span class="p">[</span><span class="mi">0</span><span class="p">,]</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">finpol</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">finpol</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="s2">&quot;r-&quot;</span><span class="p">)</span>

    <span class="c1"># set axes</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$\mathbf</span><span class="si">{X_1}</span><span class="s2">$&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$\mathbf</span><span class="si">{X_3}</span><span class="s2">$&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;equal&quot;</span><span class="p">)</span>

    <span class="c1"># Initalize progressive finite strain history</span>
    <span class="n">pfs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ninc</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">pfs</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="c1">#Initial state</span>

    <span class="c1"># Calculate progressive finite strain history</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">ninc</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        
        <span class="c1"># Determine the finite deformation gradient tensor</span>
        <span class="n">finF</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_power</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        
        <span class="c1"># Determine Green deformation tensor</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">finF</span><span class="p">,</span><span class="n">finF</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
        
        <span class="c1"># Stretch magnitude and orientation: Maximum </span>
        <span class="c1"># eigenvalue and their corresponding eigenvectors</span>
        <span class="c1"># of Green deformation tensor</span>
        <span class="n">D</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="n">pfs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">pfs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Plot progressive finite strain history</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pfs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="n">pfs</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="s2">&quot;k.-&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$\Theta\;(\circ)$&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Maximum finite stretch&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="mi">90</span><span class="p">,</span><span class="mi">90</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">max</span><span class="p">(</span><span class="n">pfs</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">paths</span><span class="p">,</span> <span class="n">pfs</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s use this function to reproduce <a class="reference internal" href="#ch08-fig08"><span class="std std-numref">Figure 8.8</span></a>a. The notebook <a class="reference external" href="https://github.com/nfcd/compGeo/blob/master/source/notebooks/ch8-4.ipynb">ch8-4</a> shows how to do this:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import libraries</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Import function pure_shear</span>
<span class="kn">from</span> <span class="nn">compgeo.pure_shear</span> <span class="kn">import</span> <span class="n">pure_shear</span>

<span class="c1"># Initial points coordinates</span>
<span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">16</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="n">pts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mf">0.5</span><span class="p">]</span>
<span class="n">pts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">st1</span> <span class="o">=</span> <span class="mf">2.5</span>
<span class="n">ninc</span> <span class="o">=</span> <span class="mi">10</span>

<span class="n">paths</span><span class="p">,</span> <span class="n">psf</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">pure_shear</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">st1</span><span class="p">,</span> <span class="n">ninc</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ch08_strain_143_0.png" src="_images/ch08_strain_143_0.png" />
</div>
</div>
<p>As you can see the principal strain axes, <span class="math notranslate nohighlight">\(S_1\)</span> and <span class="math notranslate nohighlight">\(S_3\)</span>, do not rotate throughout the deformation (<span class="math notranslate nohighlight">\(\Theta\)</span> is 0 throughout the deformation). Pure shear is a <em>non-rotational</em> deformation.</p>
</section>
<section id="simple-shear">
<span id="ch08-5-2"></span><h3><span class="section-number">8.5.2. </span>Simple shear<a class="headerlink" href="#simple-shear" title="Permalink to this headline">#</a></h3>
<p>For plane strain and simple shear along the <span class="math notranslate nohighlight">\(\mathbf{X_1}\)</span> axis (<a class="reference internal" href="#ch08-fig08"><span class="std std-numref">Figure 8.8</span></a>b), the Green deformation gradient is:</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq49">
<span class="eqno">(8.49)<a class="headerlink" href="#equation-ch08-eq49" title="Permalink to this equation">#</a></span>\[\begin{split}
{ }^{SS}F_{i j}=\left[\begin{array}{lll}1 &amp; 0 &amp; \gamma \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1\end{array}\right]
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\gamma\)</span> is the shear strain.</p>
<p>The function <a class="reference external" href="https://github.com/nfcd/compGeo/blob/master/source/functions/simple_shear.py">simple_shear</a> deforms a collection of points using simple shear and a value of shear strain (<code class="docutils literal notranslate"><span class="pre">gamma</span></code>). The function displays the points’ displacement paths for a number of increments (<code class="docutils literal notranslate"><span class="pre">ninc</span></code>), and the progressive strain history as the value of <span class="math notranslate nohighlight">\(S_1\)</span> versus <span class="math notranslate nohighlight">\(\Theta\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>


<span class="k">def</span> <span class="nf">simple_shear</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span><span class="n">gamma</span><span class="p">,</span><span class="n">ninc</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    simple_shear computes and plots displacement paths and</span>
<span class="sd">    progressive finite strain history for simple shear</span>
<span class="sd">    parallel to the X1 axis</span>

<span class="sd">    USE: paths,pfs,fig,ax = simple_shear(pts,gamma,ninc)</span>

<span class="sd">    pts: npoints x 2 matrix with X1 and X3 coord. of points</span>
<span class="sd">    gamma = Engineering shear strain</span>
<span class="sd">    ninc = number of strain increments</span>
<span class="sd">    paths = displacement paths of points</span>
<span class="sd">    pfs = progressive finite strain history. column 1 =</span>
<span class="sd">        orientation of maximum stretch with respect to X1 </span>
<span class="sd">        in degrees, column 2 = maximum stretch magnitude</span>

<span class="sd">    fig and ax are handles to the figure and axes</span>

<span class="sd">    NOTE: Intermediate principal stretch is 1.0 (Plane </span>
<span class="sd">        strain). Output orientations are in radians</span>

<span class="sd">    Python function based on the Matlab function</span>
<span class="sd">    SimpleShear in Allmendinger et al. (2012)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Incremental engineering shear strain</span>
    <span class="n">gammainc</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">/</span><span class="n">ninc</span>

    <span class="c1"># Initialize displacement paths</span>
    <span class="n">npts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># Number of points</span>
    <span class="n">paths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ninc</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">npts</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">paths</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">pts</span> <span class="c1"># Initial points of paths</span>

    <span class="c1"># Calculate incr. deformation gradient tensor Eq. 8.44</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">gammainc</span><span class="p">],[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]])</span>

    <span class="c1"># Initialize figure</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span> <span class="c1"># 1 x 2 figure</span>

    <span class="c1"># Compute displacement paths</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npts</span><span class="p">):</span> <span class="c1"># for all points</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ninc</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># for all strain increments</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                    <span class="n">paths</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">F</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">L</span><span class="p">]</span><span class="o">*</span><span class="n">paths</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">L</span><span class="p">]</span> <span class="o">+</span> <span class="n">paths</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">]</span>
        
        <span class="c1"># Plot displacement path of point</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">paths</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">paths</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;k.-&quot;</span><span class="p">)</span>

    <span class="c1"># Plot initial polygon</span>
    <span class="n">inpol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npts</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">inpol</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">npts</span><span class="p">,]</span><span class="o">=</span><span class="n">paths</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">npts</span><span class="p">,:]</span>
    <span class="n">inpol</span><span class="p">[</span><span class="n">npts</span><span class="p">,]</span> <span class="o">=</span> <span class="n">inpol</span><span class="p">[</span><span class="mi">0</span><span class="p">,]</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">inpol</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">inpol</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="s2">&quot;b-&quot;</span><span class="p">)</span>
    
    <span class="c1"># Plot final polygon</span>
    <span class="n">finpol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npts</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">finpol</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">npts</span><span class="p">,]</span><span class="o">=</span><span class="n">paths</span><span class="p">[</span><span class="n">ninc</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">npts</span><span class="p">,:]</span>
    <span class="n">finpol</span><span class="p">[</span><span class="n">npts</span><span class="p">,]</span> <span class="o">=</span> <span class="n">finpol</span><span class="p">[</span><span class="mi">0</span><span class="p">,]</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">finpol</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">finpol</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="s2">&quot;r-&quot;</span><span class="p">)</span>

    <span class="c1"># set axes</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$\mathbf</span><span class="si">{X_1}</span><span class="s2">$&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$\mathbf</span><span class="si">{X_3}</span><span class="s2">$&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;equal&quot;</span><span class="p">)</span>

    <span class="c1"># Initalize progressive finite strain history</span>
    <span class="n">pfs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ninc</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    
    <span class="c1"># In. state: Max. extension is at 45 deg from shear zone</span>
    <span class="n">pfs</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>

    <span class="c1"># Calculate progressive finite strain history</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">ninc</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        
        <span class="c1"># Determine the finite deformation gradient tensor</span>
        <span class="n">finF</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_power</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        
        <span class="c1"># Determine Green deformation tensor</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">finF</span><span class="p">,</span><span class="n">finF</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
        
        <span class="c1"># Stretch magnitude and orientation: Maximum </span>
        <span class="c1"># eigenvalue and their corresponding eigenvectors</span>
        <span class="c1"># of Green deformation tensor</span>
        <span class="n">D</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="n">pfs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">pfs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Plot progressive finite strain history</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pfs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="n">pfs</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="s2">&quot;k.-&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$\Theta\;(\circ)$&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Maximum finite stretch&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="mi">90</span><span class="p">,</span><span class="mi">90</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">max</span><span class="p">(</span><span class="n">pfs</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">paths</span><span class="p">,</span> <span class="n">pfs</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s use this function to reproduce <a class="reference internal" href="#ch08-fig08"><span class="std std-numref">Figure 8.8</span></a>b. The notebook <a class="reference external" href="https://github.com/nfcd/compGeo/blob/master/source/notebooks/ch8-5.ipynb">ch8-5</a> shows how to do this:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import libraries</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Import function simple_shear</span>
<span class="kn">from</span> <span class="nn">compgeo.simple_shear</span> <span class="kn">import</span> <span class="n">simple_shear</span>

<span class="c1"># Initial points coordinates</span>
<span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">16</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="n">pts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mf">0.5</span><span class="p">]</span>
<span class="n">pts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="mf">2.5</span>
<span class="n">ninc</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">paths</span><span class="p">,</span> <span class="n">psf</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">simple_shear</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">ninc</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ch08_strain_150_0.png" src="_images/ch08_strain_150_0.png" />
</div>
</div>
<p>In this case, the principal strain axes, <span class="math notranslate nohighlight">\(S_1\)</span> and <span class="math notranslate nohighlight">\(S_3\)</span>, rotate throughout the deformation. <span class="math notranslate nohighlight">\(\Theta\)</span> is initially 45(as predicted by infinitesimal strain, <a class="reference internal" href="#ch08-fig04"><span class="std std-numref">Figure 8.4</span></a>), and it progressively decreases to a value of 20by the end of the deformation. Simple shear is a <em>rotational</em> deformation.</p>
</section>
<section id="general-shear">
<span id="ch08-5-3"></span><h3><span class="section-number">8.5.3. </span>General shear<a class="headerlink" href="#general-shear" title="Permalink to this headline">#</a></h3>
<p>Sub-simple shear (De Paor, 1983), or general shear, is a combination of pure shear and simple shear. If the shear direction and <span class="math notranslate nohighlight">\(S_1\)</span> are parallel to <span class="math notranslate nohighlight">\(\mathbf{X_1}\)</span>, <span class="math notranslate nohighlight">\(S_2 = 1\)</span> (plane strain), and area is constant, the Green deformation gradient is (Allmendinger et al., 2012):</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq50">
<span class="eqno">(8.50)<a class="headerlink" href="#equation-ch08-eq50" title="Permalink to this equation">#</a></span>\[\begin{split}
{ }^{GS}F_{i j}=\left[\begin{array}{lll}S_1 &amp; 0 &amp; \frac{\gamma(S_1-S_3)}{2\ln S_1} \\ 0 &amp; 1 &amp; \quad\: 0 \\ 0 &amp; 0 &amp;\quad\: S_3\end{array}\right]
\end{split}\]</div>
<p>If the shear direction is parallel to <span class="math notranslate nohighlight">\(\mathbf{X_1}\)</span>, but <span class="math notranslate nohighlight">\(S_1\)</span> is parallel to <span class="math notranslate nohighlight">\(\mathbf{X_3}\)</span>, the Green deformation gradient is (Allmendinger et al., 2012):</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq51">
<span class="eqno">(8.51)<a class="headerlink" href="#equation-ch08-eq51" title="Permalink to this equation">#</a></span>\[\begin{split}
{ }^{GS}F_{i j}=\left[\begin{array}{lll}S_3 &amp; 0 &amp; \frac{\gamma(S_3-S_1)}{2\ln S_3} \\ 0 &amp; 1 &amp; \quad\: 0 \\ 0 &amp; 0 &amp;\quad\: S_1\end{array}\right]
\end{split}\]</div>
<p>A simple dimensionless measure of the ratio of simple to pure shear is the cosine of the acute angle between the eigenvectors of the Green deformation gradient <span class="math notranslate nohighlight">\(\mathbf{F}\)</span>. This measure is known as the <em>kinematic vorticity number</em>, <span class="math notranslate nohighlight">\(W_k\)</span> (Truesdell, 1953). General shear is characterized by a <span class="math notranslate nohighlight">\(W_k\)</span> between 0 (pure shear) and 1 (simple shear).</p>
<p>The function <a class="reference external" href="https://github.com/nfcd/compGeo/blob/master/source/functions/general_shear.py">general_shear</a> deforms a collection of points using general shear and values of <span class="math notranslate nohighlight">\(S_1\)</span> (<code class="docutils literal notranslate"><span class="pre">st1</span></code>) and <span class="math notranslate nohighlight">\(\gamma\)</span> (<code class="docutils literal notranslate"><span class="pre">gamma</span></code>), for a shear direction parallel to <span class="math notranslate nohighlight">\(\mathbf{X_1}\)</span>, and <span class="math notranslate nohighlight">\(S_1\)</span> parallel (<code class="docutils literal notranslate"><span class="pre">kk</span></code> = 0) or perpendicular to the shear direction (<code class="docutils literal notranslate"><span class="pre">kk</span></code> = 1). Similar to the two previous functions, <code class="docutils literal notranslate"><span class="pre">general_shear</span></code> displays the points’ displacement paths for a number of increments (<code class="docutils literal notranslate"><span class="pre">ninc</span></code>), and <span class="math notranslate nohighlight">\(S_1\)</span> versus <span class="math notranslate nohighlight">\(\Theta\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>


<span class="k">def</span> <span class="nf">general_shear</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span><span class="n">st1</span><span class="p">,</span><span class="n">gamma</span><span class="p">,</span><span class="n">kk</span><span class="p">,</span><span class="n">ninc</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    general_shear computes displacement paths, kinematic</span>
<span class="sd">    vorticity numbers and progressive finite strain </span>
<span class="sd">    history, for general shear with a pure shear stretch,</span>
<span class="sd">    no area change, and a single shear strain</span>

<span class="sd">    USE: paths,wk,pfs,fig,ax = </span>
<span class="sd">        general_shear(pts,st1,gamma,kk,ninc)</span>

<span class="sd">    pts = npoints x 2 matrix with X1 and X3 coord. of points</span>
<span class="sd">    st1 = Pure shear stretch parallel to shear zone</span>
<span class="sd">    gamma = Engineering shear strain</span>
<span class="sd">    kk = An integer that indicates whether the maximum </span>
<span class="sd">        finite stretch is parallel (kk = 0), or </span>
<span class="sd">        perpendicular (kk=1) to the shear direction</span>
<span class="sd">    ninc = number of strain increments</span>
<span class="sd">    paths = displacement paths of points</span>
<span class="sd">    wk = Kinematic vorticity number</span>
<span class="sd">    pfs = progressive finite strain history. column 1 =</span>
<span class="sd">        orientation of maximum stretch with respect to </span>
<span class="sd">        X1, column 2 = maximum stretch magnitude</span>

<span class="sd">    fig and ax are handles to the figure and axes</span>

<span class="sd">    NOTE: Intermediate principal stretch is 1.0 (Plane</span>
<span class="sd">        strain). Output orientations are in radians</span>

<span class="sd">    Python function translated from the Matlab function</span>
<span class="sd">    GeneralShear in Allmendinger et al. (2012)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Compute minimum principal stretch and incr. stretches</span>
    <span class="n">st1inc</span> <span class="o">=</span><span class="n">st1</span><span class="o">**</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">ninc</span><span class="p">)</span>
    <span class="n">st3</span> <span class="o">=</span><span class="mf">1.0</span><span class="o">/</span><span class="n">st1</span>
    <span class="n">st3inc</span> <span class="o">=</span><span class="n">st3</span><span class="o">**</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">ninc</span><span class="p">)</span>

    <span class="c1"># Incremental engineering shear strain</span>
    <span class="n">gammainc</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">/</span><span class="n">ninc</span>

    <span class="c1"># Initialize displacement paths</span>
    <span class="n">npts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># Number of points</span>
    <span class="n">paths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ninc</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">npts</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">paths</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">pts</span> <span class="c1"># Initial points of paths</span>

    <span class="c1"># Initialize figure</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span> <span class="c1"># 1 x 2 figure</span>

    <span class="c1"># Calculate incremental deformation gradient tensor</span>
    <span class="c1"># If max. stretch parallel to shear direction Eq. 8.45</span>
    <span class="k">if</span> <span class="n">kk</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">F</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">F</span><span class="p">[</span><span class="mi">0</span><span class="p">,]</span><span class="o">=</span><span class="p">[</span><span class="n">st1inc</span><span class="p">,</span> <span class="p">(</span><span class="n">gammainc</span><span class="o">*</span><span class="p">(</span><span class="n">st1inc</span><span class="o">-</span><span class="n">st3inc</span><span class="p">))</span><span class="o">/</span>
            <span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">st1inc</span><span class="p">))]</span>
        <span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">,]</span><span class="o">=</span><span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">st3inc</span><span class="p">]</span>
    
    <span class="c1"># If max. stretch perpendicular to shear direction Eq. 8.46</span>
    <span class="k">elif</span> <span class="n">kk</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">F</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">F</span><span class="p">[</span><span class="mi">0</span><span class="p">,]</span><span class="o">=</span> <span class="p">[</span><span class="n">st3inc</span><span class="p">,</span> <span class="p">(</span><span class="n">gammainc</span><span class="o">*</span><span class="p">(</span><span class="n">st3inc</span><span class="o">-</span><span class="n">st1inc</span><span class="p">))</span><span class="o">/</span>
                            <span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">st3inc</span><span class="p">))]</span>
        <span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">,]</span><span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">st1inc</span><span class="p">]</span>

    <span class="c1"># Compute displacement paths</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npts</span><span class="p">):</span> <span class="c1"># for all points</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ninc</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># for all strain increments</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                    <span class="n">paths</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">F</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">L</span><span class="p">]</span><span class="o">*</span><span class="n">paths</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">L</span><span class="p">]</span> <span class="o">+</span> <span class="n">paths</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">]</span>
        
        <span class="c1"># Plot displacement path of point</span>
        <span class="n">xx</span> <span class="o">=</span> <span class="n">paths</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">yy</span> <span class="o">=</span> <span class="n">paths</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span><span class="n">yy</span><span class="p">,</span><span class="s2">&quot;k.-&quot;</span><span class="p">)</span>

    <span class="c1"># Plot initial and final polygons</span>
    <span class="n">inpol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npts</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">inpol</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">npts</span><span class="p">,]</span><span class="o">=</span><span class="n">paths</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">npts</span><span class="p">,:]</span>
    <span class="n">inpol</span><span class="p">[</span><span class="n">npts</span><span class="p">,]</span> <span class="o">=</span> <span class="n">inpol</span><span class="p">[</span><span class="mi">0</span><span class="p">,]</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">inpol</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">inpol</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="s2">&quot;b-&quot;</span><span class="p">)</span>
    <span class="n">finpol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npts</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">finpol</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">npts</span><span class="p">,]</span><span class="o">=</span><span class="n">paths</span><span class="p">[</span><span class="n">ninc</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">npts</span><span class="p">,:]</span>
    <span class="n">finpol</span><span class="p">[</span><span class="n">npts</span><span class="p">,]</span> <span class="o">=</span> <span class="n">finpol</span><span class="p">[</span><span class="mi">0</span><span class="p">,]</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">finpol</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">finpol</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="s2">&quot;r-&quot;</span><span class="p">)</span>

    <span class="c1"># Set axes</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$\mathbf</span><span class="si">{X_1}</span><span class="s2">$&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$\mathbf</span><span class="si">{X_3}</span><span class="s2">$&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;equal&quot;</span><span class="p">)</span>

    <span class="c1"># Determine the eigenvectors of the flow (apophyses)</span>
    <span class="c1"># Since F is not symmetrical, use function eig</span>
    <span class="n">_</span><span class="p">,</span><span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
    <span class="n">theta2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">wk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta2</span><span class="p">)</span>

    <span class="c1"># Initalize progressive finite strain history. </span>
    <span class="c1"># We are not including the initial state</span>
    <span class="n">pfs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ninc</span><span class="p">,</span><span class="n">ninc</span><span class="p">))</span>

    <span class="c1"># Calculate progressive finite strain history</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">ninc</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        
        <span class="c1"># Determine the finite deformation gradient tensor</span>
        <span class="n">finF</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_power</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        
        <span class="c1"># Determine Green deformation tensor</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">finF</span><span class="p">,</span><span class="n">finF</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
        
        <span class="c1"># Stretch magnitude and orientation: Maximum </span>
        <span class="c1"># eigenvalue and their corresponding eigenvectors</span>
        <span class="c1"># of Green deformation tensor</span>
        <span class="n">D</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="n">pfs</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">pfs</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Plot progressive finite strain history</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pfs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="n">pfs</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="s2">&quot;k.-&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$\Theta\;(\circ)$&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Maximum finite stretch&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="mi">90</span><span class="p">,</span><span class="mi">90</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">max</span><span class="p">(</span><span class="n">pfs</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">paths</span><span class="p">,</span> <span class="n">wk</span><span class="p">,</span> <span class="n">pfs</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s use this function to simulate the deformation produced by <span class="math notranslate nohighlight">\(S_1 = 2.0\)</span> and <span class="math notranslate nohighlight">\(\gamma = 0.5\)</span>, for a shear direction parallel to <span class="math notranslate nohighlight">\(\mathbf{X_1}\)</span>, and <span class="math notranslate nohighlight">\(S_1\)</span> parallel or perpendicular to <span class="math notranslate nohighlight">\(\mathbf{X_1}\)</span>. The notebook <a class="reference external" href="https://github.com/nfcd/compGeo/blob/master/source/notebooks/ch8-6.ipynb">ch8-6</a> shows the solution to this problem:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import libraries</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Import function general_shear</span>
<span class="kn">from</span> <span class="nn">compgeo.general_shear</span> <span class="kn">import</span> <span class="n">general_shear</span>

<span class="c1"># Initial points coordinates</span>
<span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">16</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="n">pts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mf">0.5</span><span class="p">]</span>
<span class="n">pts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">st1</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="n">ninc</span> <span class="o">=</span> <span class="mi">10</span>

<span class="c1"># Max. finite stretch parallel to shear direction</span>
<span class="n">kk</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">paths1</span><span class="p">,</span> <span class="n">wk1</span><span class="p">,</span> <span class="n">psf1</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">general_shear</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">st1</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">kk</span><span class="p">,</span> <span class="n">ninc</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Wk = </span><span class="si">{:.4f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">wk1</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Wk = 0.3393
</pre></div>
</div>
<img alt="_images/ch08_strain_159_1.png" src="_images/ch08_strain_159_1.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Max. finite stretch perpendicular to shear direction</span>
<span class="n">kk</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">paths2</span><span class="p">,</span> <span class="n">wk2</span><span class="p">,</span> <span class="n">pfs2</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">general_shear</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">st1</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">kk</span><span class="p">,</span> <span class="n">ninc</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Wk = </span><span class="si">{:.4f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">wk2</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Wk = 0.3393
</pre></div>
</div>
<img alt="_images/ch08_strain_160_1.png" src="_images/ch08_strain_160_1.png" />
</div>
</div>
<p>In this case, the contribution of simple shear is about one third that of pure shear (<span class="math notranslate nohighlight">\(W_k = 0.34\)</span>). Try running the notebook with different values of <span class="math notranslate nohighlight">\(S_1\)</span> and <span class="math notranslate nohighlight">\(\gamma\)</span>, and check <span class="math notranslate nohighlight">\(W_k\)</span> and <span class="math notranslate nohighlight">\(\Theta\)</span>.</p>
</section>
</section>
<section id="exercises">
<span id="ch08-6"></span><h2><span class="section-number">8.6. </span>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">#</a></h2>
<ol>
<li><p>This exercise is from Rowland and Duebendorfer (1994). The file <a class="reference external" href="https://github.com/nfcd/compGeo/blob/master/source/data/ch8-exercise1/bar.txt">bar.txt</a> contains the strike and dip (RHR), slip direction, and slip sense of faults within the Basin and Range province, specifically southern Nevada and the Lake Mead area. Plot the <strong>P</strong> and <strong>T</strong> axes for these data using the function <code class="docutils literal notranslate"><span class="pre">pt_axes</span></code>. Are these data consistent with the regional E-W extension direction in the Basin and Range province?</p></li>
<li><p>From the <strong>P</strong> and <strong>T</strong> axes, one can compute an unweighted moment tensor summation as follows (Allmendinger et al., 1989):</p>
<div class="math notranslate nohighlight" id="equation-ch08-eq52">
<span class="eqno">(8.52)<a class="headerlink" href="#equation-ch08-eq52" title="Permalink to this equation">#</a></span>\[\begin{split}
    \scriptstyle \mathbf{K} = \left[\begin{array}{ccc}\scriptstyle\sum (P_N)^{2} - (T_N)^{2}  &amp; \scriptstyle\sum (P_N) (P_E) - (T_N) (T_E) &amp; \scriptstyle\sum (P_N) (P_D) - (T_N) (T_D) \\ \scriptstyle\sum (P_E) (P_N) - (T_E) (T_N) &amp; \scriptstyle\sum (P_E)^{2} - (T_E)^{2} &amp; \scriptstyle\sum (P_E) (P_D) - (T_E) (T_D) \\ \scriptstyle\sum (P_D) (P_N) - (T_D) (T_N) &amp; \scriptstyle\sum (P_D) (P_E) - (T_D) (T_E) &amp; \scriptstyle\sum (P_D)^{2} - (T_D)^{2}\end{array}\right]
    \end{split}\]</div>
<p>where the subscripts <span class="math notranslate nohighlight">\(N\)</span>, <span class="math notranslate nohighlight">\(E\)</span>, and <span class="math notranslate nohighlight">\(D\)</span> refer to the east, north and  down direction cosines of the <strong>P</strong> and <strong>T</strong> axes. The eigenvalues and eigenvectors of <span class="math notranslate nohighlight">\(\mathbf{K}\)</span> give the relative magnitudes and orientations of the kinematic axes. These kinematic axes define the orientation of two nodal planes, or possible faults, separating the areas of infinitesimal extension (<strong>T</strong> axes) from those of infinitesimal shortening (<strong>P</strong> axes). The faults intersect at the intermediate eigenvector, the minimum and maximum eigenvectors define the movement plane, and the faults slip vectors are on the movement plane at 45 from the minimum and maximum eigenvectors. Modify the function <code class="docutils literal notranslate"><span class="pre">pt_axes</span></code> to plot the nodal planes. This is not a simple problem, don’t give up.</p>
</li>
<li><p>The file <a class="reference external" href="https://github.com/nfcd/compGeo/blob/master/source/data/ch8-exercise2/andes.txt">andes.txt</a> contains GPS data (stations UTM coordinates and displacements in meters) from the Central Andes (Kendrick et al., 2001; Brooks et al., 2003). Compute the infinitesimal rotation in this region using the function <code class="docutils literal notranslate"><span class="pre">grid_strain</span></code>. What does the rotation tell you about the tectonics of this region? Check Allmendinger et al. (2005) to support your answer.</p></li>
<li><p>The file <a class="reference external" href="https://github.com/nfcd/compGeo/blob/master/source/data/ch8-exercise3/antithetic.txt">antithetic.txt</a> contains data from a discrete element model of a low angle normal fault (deformed elements’ coordinates and displacements). Use the function <code class="docutils literal notranslate"><span class="pre">grid_fin_strain</span></code> to compute the shear strain of this model.</p></li>
<li><p>The file <a class="reference external" href="https://github.com/nfcd/compGeo/blob/master/source/data/ch8-exercise4/trilobite.txt">trilobite.txt</a> contains the undeformed <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> coordinates of points delineating a trilobite specimen. Deform the trilobite using <strong>a.</strong> pure shear with <span class="math notranslate nohighlight">\(S_1 = 2.0\)</span>, <strong>b.</strong> simple shear with <span class="math notranslate nohighlight">\(\gamma = 1.0\)</span>, and <strong>c.</strong> general shear with <span class="math notranslate nohighlight">\(S_1 = 1.5\)</span>, <span class="math notranslate nohighlight">\(\gamma = 1.0\)</span>, and shear direction and <span class="math notranslate nohighlight">\(S_1\)</span> parallel to <span class="math notranslate nohighlight">\(x\)</span>.</p></li>
</ol>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>Use functions <code class="docutils literal notranslate"><span class="pre">pure_shear</span></code>, <code class="docutils literal notranslate"><span class="pre">simple_shear</span></code>, and <code class="docutils literal notranslate"><span class="pre">general_shear</span></code>.</p>
</div>
</section>
<section id="references">
<span id="ch08-7"></span><h2><span class="section-number">8.7. </span>References<a class="headerlink" href="#references" title="Permalink to this headline">#</a></h2>
<p>Allmendinger, R.W., Gephart, J.W. and Marrett, R.A. 1989. Notes on fault
slip analysis. GSA short course.</p>
<p>Allmendinger, R.W., Smalley, R.J., Bevis, M. et al. 2005. Bending the
Bolivian orocline in real time. Geology 33, 905-908.</p>
<p>Allmendinger, R.W., Reilinger, R. and Loveless, J. 2007. Strain and
rotation rate from GPS in Tibet, Anatolia, and the Altiplano. Tectonics
26, TC3013.</p>
<p>Allmendinger, R.W., Cardozo, N. and Fisher, D.M. 2012. Structural
Geology Algorithms: Vectors and Tensors. Cambridge University Press.</p>
<p>Brooks, B. A., Bevis, M., R. Smalley, J. et al. 2003. Crustal Motion in
the Southern Andes (26-36S): do the Andes behave like a microplate?
Geochemistry, Geophysics, Geosystems - G3 4, GC000505.</p>
<p>Cardozo, N. and Allmendinger, R.W. 2009. SSPX: A program to compute
strain from displacement/velocity data. Computers and Geosciences 35,
1343-1357.</p>
<p>DePaor, D.G. 1983. Ortographic analysis of geological structures - I.
Deformation theory. Journal of Structural Geology 5, 255-277.</p>
<p>Kendrick, E., Bevis, M., Smalley, R. and Brooks, B. 2001. An integrated
crustal velocity field for the Central Andes. Geochemistry, Geophysics,
Geosystems - G3 2, GC000191.</p>
<p>Marshak, S. and Mitra, G. 1988. Basic Methods of Structural Geology.
Prentice Hall.</p>
<p>Means, W.D. 1976. Stress and Strain: Basic Concepts of Continuum
Mechanics for Geologists. New York: Springer-Verlag.</p>
<p>Press, W.H., Flannery, B.P., Teoukolsky, S.A. and Vetterling, W.T. 1986.
Numerical Recipes: The Art of Scientific Computing. Cambridge University
Press.</p>
<p>Ragan, D.M. 2009. Structural Geology: An Introduction to Geometrical
Techniques. Cambridge University Press.</p>
<p>Ramsay, J.G. 1967. Folding and Fracturing of Rocks. McGraw-Hill, New
York.</p>
<p>Rowland, S.M. and Duebendorfer, E.M. 1994. Structural Analysis and
Synthesis: A Laboratory Course in Structural Geology. Wiley.</p>
<p>Truesdell, C. 1953. Two measures of vorticity. Journal of Rational
Mechanics and Analysis 2, 173-217.</p>
<p>Zhang, P., Zhengkang, S., Min, W., et al. 2004, Continuous deformation
of the Tibetan Plateau from Global Positioning System data: Geology 32,
809-812.</p>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "afantunes74/compgeo_tests",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="ch07_stress.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title"><span class="section-number">7. </span>Stress</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="ch09_elasticity.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">9. </span>Elasticity</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Nestor Cardozo<br/>
  
      &copy; Copyright 2023.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>